var documenterSearchIndex = {"docs":
[{"location":"math-model/#The-PowerModels-Mathematical-Model","page":"Mathematical Model","title":"The PowerModels Mathematical Model","text":"","category":"section"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"As PowerModels implements a variety of power network optimization problems, the implementation is the best reference for precise mathematical formulations.  This section provides a complex number based mathematical specification for a prototypical AC Optimal Power Flow problem, to provide an overview of the typical mathematical models in PowerModels.","category":"page"},{"location":"math-model/#Sets-and-Parameters","page":"Mathematical Model","title":"Sets and Parameters","text":"","category":"section"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"PowerModels implements a slightly generalized version of the AC Optimal Power Flow problem from Matpower.  These generalizations make it possible for PowerModels to more accurately capture industrial transmission network datasets.  The core generalizations are,","category":"page"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"Support for multiple load (S^d_k) and shunt (Y^s_k) components on each bus i\nLine charging that supports a conductance and asymmetrical values (Y^c_ij Y^c_ji)","category":"page"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign\n\nmboxsets  nonumber \n N mbox - busesnonumber \n R mbox - reference busesnonumber \n E E^R mbox - branches forward and reverse orientation nonumber \n G G_i mbox - generators and generators at bus i nonumber \n L L_i mbox - loads and loads at bus i nonumber \n S S_i mbox - shunts and shunts at bus i nonumber \n\nmboxdata  nonumber \n S^gl_k S^gu_k  forall k in G nonumber mbox - generator complex power bounds\n c_2k c_1k c_0k  forall k in G nonumber  mbox - generator cost components\n v^l_i v^u_i  forall i in N nonumber mbox - voltage bounds\n S^d_k  forall k in L nonumber mbox - load complex power consumption\n Y^s_k  forall k in S nonumber mbox - bus shunt admittance\n Y_ij Y^c_ij Y^c_ji  forall (ij) in E nonumber mbox - branch pi-section parameters\n T_ij  forall (ij) in E nonumber mbox - branch complex transformation ratio\n s^u_ij   forall (ij) in E nonumber mbox - branch apparent power limit\n i^u_ij   forall (ij) in E nonumber mbox - branch current limit\n theta^Delta l_ij theta^Delta u_ij  forall (ij) in E nonumber mbox - branch voltage angle difference bounds\n\nendalign","category":"page"},{"location":"math-model/#AC-Optimal-Power-Flow","page":"Mathematical Model","title":"AC Optimal Power Flow","text":"","category":"section"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"A complete mathematical model is as follows,","category":"page"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign\n\nmboxvariables   nonumber \n S^g_k  forall kin G mbox - generator complex power dispatch labelvar_generation\n V_i  forall iin N labelvar_voltage mbox - bus complex voltage\n S_ij  forall (ij) in E cup E^R  labelvar_complex_power mbox - branch complex power flow\n\nmboxminimize   sum_k in G c_2k (Re(S^g_k))^2 + c_1kRe(S^g_k) + c_0k labeleq_objective\n\nmboxsubject to   nonumber \n angle V_r = 0   forall r in R labeleq_ref_bus\n S^gl_k leq S^g_k leq S^gu_k  forall k in G  labeleq_gen_bounds\n v^l_i leq V_i leq v^u_i  forall i in N labeleq_voltage_bounds\n sum_substackk in G_i S^g_k - sum_substackk in L_i S^d_k - sum_substackk in S_i (Y^s_k)^* V_i^2 = sum_substack(ij)in E_i cup E_i^R S_ij  forall iin N labeleq_kcl_shunt \n S_ij = left( Y_ij + Y^c_ijright)^* fracV_i^2T_ij^2 - Y^*_ij fracV_i V^*_jT_ij  forall (ij)in E labeleq_power_from\n S_ji = left( Y_ij + Y^c_ji right)^* V_j^2 - Y^*_ij fracV^*_i V_jT^*_ij  forall (ij)in E labeleq_power_to\n S_ij leq s^u_ij  forall (ij) in E cup E^R labeleq_thermal_limit\n S_ij leq V_i i^u_ij  forall (ij) in E cup E^R labeleq_current_limit\n theta^Delta l_ij leq angle (V_i V^*_j) leq theta^Delta u_ij  forall (ij) in E labeleq_angle_difference\n\nendalign","category":"page"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"Note that for clarity of this presentation some model variants that PowerModels supports have been omitted (e.g. piecewise linear cost functions and HVDC lines).  Details about these variants is available in the Matpower documentation.","category":"page"},{"location":"math-model/#Mapping-to-PowerModels-Functions","page":"Mathematical Model","title":"Mapping to PowerModels Functions","text":"","category":"section"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"Eq. eqrefvar_generation - variable_gen_power\nEq. eqrefvar_voltage - variable_bus_voltage\nEq. eqrefvar_complex_power - variable_branch_power\nEq. eqrefeq_objective - objective_min_fuel_cost\nEq. eqrefeq_ref_bus - constraint_theta_ref\nEq. eqrefeq_gen_bounds - bounds of variable_gen_power\nEq. eqrefeq_voltage_bounds - bounds of variable_bus_voltage\nEq. eqrefeq_kcl_shunt - constraint_power_balance\nEq. eqrefeq_power_from - constraint_ohms_yt_from\nEq. eqrefeq_power_to - constraint_ohms_yt_to\nEq. eqrefeq_thermal_limit - constraint_thermal_limit_from and constraint_thermal_limit_to\nEq. eqrefeq_current_limit - constraint_current_limit\nEq. eqrefeq_angle_difference - constraint_voltage_angle_difference","category":"page"},{"location":"math-model/#AC-Optimal-Power-Flow-for-the-Branch-Flow-Model","page":"Mathematical Model","title":"AC Optimal Power Flow for the Branch Flow Model","text":"","category":"section"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"The same assumptions apply as before. The series impedance is Z_ij=(Y_ij)^-1. In comparison  with the BIM, a new variable I^s_ij, representing the current in the direction i to j, through the series part of the pi-section, is introduced. A complete mathematical formulation for a Branch Flow Model is conceived as:","category":"page"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign\n\nmboxvariables   nonumber \n S^g_k  forall kin G nonumber \n V_i  forall iin N nonumber \n S_ij  forall (ij) in E cup E^R nonumber \n I^s_ij  forall (ij) in E cup E^R labelvar_branch_current  mbox - branch complex (series) current\n\nmboxminimize   sum_k in G c_2k (Re(S^g_k))^2 + c_1kRe(S^g_k) + c_0k nonumber\n\nmboxsubject to   nonumber \n angle V_r = 0   forall r in R nonumber \n S^gl_k leq S^g_k leq S^gu_k  forall k in G nonumber \n v^l_i leq V_i leq v^u_i  forall i in N nonumber\n sum_substackk in G_i S^g_k - sum_substackk in L_i S^d_k - sum_substackk in S_i (Y^s_k)^* V_i^2 = sum_substack(ij)in E_i cup E_i^R S_ij  forall iin N nonumber\n S_ij +  S_ji = left(Y^c_ijright)^* fracV_i^2T_ij^2 + Z_ij I^s_ij^2 +  left(Y^c_jiright)^* V_j^2   forall (ij)in E labeleq_line_losses \n S_ij = S^s_ij + left(Y^c_ijright)^* fracV_i^2T_ij^2   forall (ij)in E labeleq_series_power_flow \n S^s_ij = fracV_iT_ij (I^s_ij)^*   forall (ij)in E labeleq_complex_power_definition \n fracV_iT_ij = V_j + z_ij I^s_ij   forall (ij)in E labeleq_ohms_bfm \n S_ij leq s^u_ij  forall (ij) in E cup E^R nonumber\n I_ij leq i^u_ij  forall (ij) in E cup E^R nonumber\n theta^Delta l_ij leq angle (V_i V^*_j) leq theta^Delta u_ij  forall (ij) in E nonumber\n\nendalign","category":"page"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"Note that constraints eqrefeq_line_losses - eqrefeq_ohms_bfm replace eqrefeq_power_from - eqrefeq_power_to but the remainder of the problem formulation is identical. Furthermore, the problems have the same feasible set.  ","category":"page"},{"location":"math-model/#Mapping-to-PowerModels-Functions-2","page":"Mathematical Model","title":"Mapping to PowerModels Functions","text":"","category":"section"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"Eq. eqrefvar_branch_current - variable_branch_current\nEq. eqrefeq_line_losses - constraint_power_losses\nEq. eqrefeq_series_power_flow - implicit, substituted out before implementation\nEq. eqrefeq_complex_power_definition - constraint_model_voltage\nEq. eqrefeq_ohms_bfm - constraint_voltage_magnitude_difference","category":"page"},{"location":"math-model/#AC-Optimal-Power-Flow-in-Current-Voltage-Variables","page":"Mathematical Model","title":"AC Optimal Power Flow in Current-Voltage Variables","text":"","category":"section"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"A variable I^s_ij, representing the current in the direction i to j, through the series part of the pi-section, is used. The mathematical structure for a current-voltage formulation is conceived as:","category":"page"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"beginalign\n\nmboxvariables   nonumber \n I^g_k  forall kin G nonumber \n V_i  forall iin N nonumber \n I^s_ij  forall (ij) in E cup E^R  mbox - branch complex (series) current\n I_ij  forall (ij) in E cup E^R  mbox - branch complex (total) current labelvar_total_current\n\nmboxminimize   sum_k in G c_2k (Re(S^g_k))^2 + c_1kRe(S^g_k) + c_0k nonumber\n\nmboxsubject to   nonumber \n angle V_r = 0   forall r in R nonumber \n S^gl_k leq V_i (I^g_k)^* leq S^gu_k  forall k in G   labeleq_complex_power_definition_gen\n v^l_i leq V_i leq v^u_i  forall i in N nonumber\n sum_substackk in G_i I^g_k - sum_substackk in L_i left(fracS^d_kV_iright)^* - sum_substackk in S_i Y^s_k V_i = sum_substack(ij)in E_i cup E_i^R I_ij  forall iin N  labeleq_kcl_current \n I_ij =  fracI^s_ijT_ij^* + Y^c_ij fracV_iT_ij^2   forall (ij)in E labeleq_current_from \n I_ji = -I^s_ij + Y^c_ji V_j   forall (ij)in E labeleq_current_to \n fracV_iT_ij = V_j + z_ij I^s_ij   forall (ij) in E labeleq_ohms_iv \n V_i I_ij leq s^u_ij  forall (ij) in E cup E^R nonumber\n I_ij leq i^u_ij  forall (ij) in E cup E^R nonumber\n theta^Delta l_ij leq angle (V_i V^*_j) leq theta^Delta u_ij  forall (ij) in E nonumber\n\nendalign","category":"page"},{"location":"math-model/#Mapping-to-PowerModels-Functions-3","page":"Mathematical Model","title":"Mapping to PowerModels Functions","text":"","category":"section"},{"location":"math-model/","page":"Mathematical Model","title":"Mathematical Model","text":"Eq. eqrefvar_total_current - total current flow into a branch on either end variable_branch_current\nEq. eqrefeq_complex_power_definition_gen  - models active and reactive power range of a generator variable_gen_current\nEq. eqrefeq_kcl_current  - Kirchhoff's current law in current variables  constraint_current_balance\nEq. eqrefeq_current_from  - branch from-side current constraint in constraint_current_from\nEq. eqrefeq_current_to  - branch to-side current constraint in constraint_current_to\nEq. eqrefeq_ohms_iv  - Ohm's law constraint_voltage_drop","category":"page"},{"location":"utilities/#PowerModels-Utility-Functions","page":"Utilities","title":"PowerModels Utility Functions","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"This section provides an overview of the some of the utility functions that are implemented as a part of the PowerModels julia package.","category":"page"},{"location":"utilities/#Optimization-Based-Bound-Tightening-for-the-AC-Optimal-Power-Flow-Problem","page":"Utilities","title":"Optimization-Based Bound-Tightening for the AC Optimal Power Flow Problem","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"To improve the quality of the convex relaxations available in PowerModels and also to obtain tightened bounds on the voltage-magnitude and phase-angle difference variables, an optimization-based bound-tightening algorithm is made available as a function in PowerModels.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"solve_obbt_opf!","category":"page"},{"location":"utilities/#PowerModels.solve_obbt_opf!","page":"Utilities","title":"PowerModels.solve_obbt_opf!","text":"Iteratively tighten bounds on voltage magnitude and phase-angle difference variables.\n\nThe function can be invoked on any convex relaxation which explicitly has these variables. By default, the function uses the QC relaxation for performing bound-tightening. Interested readers are refered to the paper \"Strengthening Convex Relaxations with Bound Tightening for Power Network Optimization\".\n\nExample\n\nThe function can be invoked as follows:\n\ndata, stats = solve_obbt_opf!(\"matpower/case3.m\", Ipopt.Optimizer)\n\ndata contains the parsed network data with tightened bounds. stats contains information output from the bounds-tightening algorithm. It looks roughly like\n\nDict{String,Any} with 19 entries:\n  \"initial_relaxation_objective\" => 5817.91\n  \"vm_range_init\"                => 0.6\n  \"final_relaxation_objective\"   => 5901.96\n  \"avg_vm_range_init\"            => 0.2\n  \"final_rel_gap_from_ub\"        => NaN\n  \"run_time\"                     => 0.832232\n  \"model_type\"            => AbstractPowerModel\n  \"avg_td_range_final\"           => 0.436166\n  \"initial_rel_gap_from_ub\"      => Inf\n  \"sim_parallel_run_time\"        => 1.13342\n  \"upper_bound\"                  => Inf\n  \"vm_range_final\"               => 0.6\n  \"vad_sign_determined\"          => 2\n  \"avg_td_range_init\"            => 1.0472\n  \"avg_vm_range_final\"           => 0.2\n  \"iteration_count\"              => 5\n  \"td_range_init\"                => 3.14159\n  \"td_range_final\"               => 1.3085\n\nKeyword Arguments\n\nmodel_type: relaxation to use for performing bound-tightening.   Currently, it supports any relaxation that has explicit voltage magnitude   and phase-angle difference variables.\nmax_iter: maximum number of bound-tightening iterations to perform.\ntime_limit: maximum amount of time (sec) for the bound-tightening algorithm.\nupper_bound: can be used to specify a local feasible solution objective for   the AC Optimal Power Flow problem.\nupper_bound_constraint: boolean option that can be used to add an additional   constraint to reduce the search space of each of the bound-tightening   solves. This cannot be set to true without specifying an upper bound.\nrel_gap_tol: tolerance used to terminate the algorithm when the objective   value of the relaxation is close to the upper bound specified using the   upper_bound keyword.\nmin_bound_width: domain beyond which bound-tightening is not performed.\ntermination: Bound-tightening algorithm terminates if the improvement in   the average or maximum bound improvement, specified using either the   termination = :avg or the termination = :max option, is less than   improvement_tol.\nprecision: number of decimal digits to round the tightened bounds to.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#Lazy-Line-Flow-Limits","page":"Utilities","title":"Lazy Line Flow Limits","text":"","category":"section"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"The following functions are meta-algorithms for solving OPF problems where line flow limit constraints are added iteratively to exploit the property that the majority of line flows constraints will be inactive in the optimal solution.","category":"page"},{"location":"utilities/","page":"Utilities","title":"Utilities","text":"solve_opf_branch_power_cuts\nsolve_opf_ptdf_branch_power_cuts","category":"page"},{"location":"utilities/#PowerModels.solve_opf_branch_power_cuts","page":"Utilities","title":"PowerModels.solve_opf_branch_power_cuts","text":"Solves the OPF problem by iteratively adding line flow constraints based on  constraint violations\n\nKeyword Arguments\n\nmodel_type: the power flow formulaiton.\nmax_iter: maximum number of flow iterations to perform.\ntime_limit: maximum amount of time (sec) for the algorithm.\n\n\n\n\n\n","category":"function"},{"location":"utilities/#PowerModels.solve_opf_ptdf_branch_power_cuts","page":"Utilities","title":"PowerModels.solve_opf_ptdf_branch_power_cuts","text":"Solves the PTDF variant of the OPF problem by iteratively adding line flow constraints based on constraint violations.\n\nCurrently the DCPPowerModel is used in this solver as that is the only model supporting the PTDF problem specification at this time.\n\nKeyword Arguments\n\nmax_iter: maximum number of flow iterations to perform.\ntime_limit: maximum amount of time (sec) for the algorithm.\nfull_inverse: compute the complete admittance matrix inverse, instead of a branch by branch computation.\n\n\n\n\n\n","category":"function"},{"location":"relaxations/#Relaxation-Schemes","page":"Relaxation Schemes","title":"Relaxation Schemes","text":"","category":"section"},{"location":"relaxations/","page":"Relaxation Schemes","title":"Relaxation Schemes","text":"Modules = [PowerModels]\nPages   = [\"core/relaxation_scheme.jl\"]\nOrder   = [:function]\nPrivate  = true","category":"page"},{"location":"relaxations/#PowerModels.cut_complex_product_and_angle_difference-NTuple{7, Any}","page":"Relaxation Schemes","title":"PowerModels.cut_complex_product_and_angle_difference","text":"A valid inequality for the product of two complex variables with magnitude and angle difference bounds.\n\nIn the literature this constraints are called the Lifted Nonlinear Cuts (LNCs).\n\n@misc{1512.04644,     Author = {Carleton Coffrin and Hassan Hijazi and Pascal Van Hentenryck},     Title = {Strengthening the SDP Relaxation of AC Power Flows with Convex         Envelopes, Bound Tightening, and Lifted Nonlinear Cuts},     Year = {2015},     Eprint = {arXiv:1512.04644}, }\n\n\n\n\n\n","category":"method"},{"location":"relaxations/#PowerModels.cut_product_replicates-NTuple{5, Any}","page":"Relaxation Schemes","title":"PowerModels.cut_product_replicates","text":"A valid inequality for when the same product of two variables occurs in two different higher order products (e.g. trilinear terms).\n\n@misc{1809.04565,     Author = {Kaarthik Sundar and Harsha Nagarajan and Sidhant Misra and         Mowen Lu and Carleton Coffrin and Russell Bent},     Title = {Optimization-Based Bound Tightening using a Strengthened         QC-Relaxation of the Optimal Power Flow Problem},     Year = {2018},     Eprint = {arXiv:1809.04565}, }\n\n\n\n\n\n","category":"method"},{"location":"relaxations/#PowerModels.relaxation_cos-Tuple{Any, Any, Any}","page":"Relaxation Schemes","title":"PowerModels.relaxation_cos","text":"general relaxation of a cosine term, in -pi/2 to pi/2\n\n\n\n\n\n","category":"method"},{"location":"relaxations/#PowerModels.relaxation_cos_on_off-NTuple{5, Any}","page":"Relaxation Schemes","title":"PowerModels.relaxation_cos_on_off","text":"general relaxation of a cosine term, in -pi/2 to pi/2\n\n\n\n\n\n","category":"method"},{"location":"relaxations/#PowerModels.relaxation_sin-Tuple{Any, Any, Any}","page":"Relaxation Schemes","title":"PowerModels.relaxation_sin","text":"general relaxation of a sine term, in -pi/2 to pi/2\n\n\n\n\n\n","category":"method"},{"location":"relaxations/#PowerModels.relaxation_sin_on_off-NTuple{5, Any}","page":"Relaxation Schemes","title":"PowerModels.relaxation_sin_on_off","text":"general relaxation of a sine term, in -pi/2 to pi/2\n\n\n\n\n\n","category":"method"},{"location":"experiment-results/#PowerModels-Experiment-Results","page":"Experiment Results","title":"PowerModels Experiment Results","text":"","category":"section"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"This section presents results of running PowerModels on collections of established power network test cases from the PGLib-OPF archive. This provides validation of PowerModels as well as a results baseline for these test cases. All models were solved using IPOPT.","category":"page"},{"location":"experiment-results/#Experiment-Design","page":"Experiment Results","title":"Experiment Design","text":"","category":"section"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"This experiment consists of running the following PowerModels commands,","category":"page"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"solver = optimizer_with_attributes(Ipopt.Optimizer, \"tol\" => 1e-6)\nresult_ac  = solve_opf(case,   ACPPowerModel, solver)\nresult_soc = solve_opf(case, SOCWRPowerModel, solver)\nresult_qc  = solve_opf(case,  QCRMPowerModel, solver)","category":"page"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"for each case in the PGLib-OPF archive. If the value of result[\"termination_status\"] is LOCALLY_SOLVED then the values of result[\"objective\"] and result[\"solve_time\"] are reported, otherwise an err. or -- is displayed.  A value of n.d. indicates that no data was available.   The optimality gap is defined as,","category":"page"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"soc_gap = 100*(result_ac[\"objective\"] - result_soc[\"objective\"])/result_ac[\"objective\"]","category":"page"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"It is important to note that the result[\"solve_time\"] value in this experiment does not include Julia's JIT time, about 2-5 seconds. The results were computed using the HSL ma57 solver in IPOPT. The default linear solver provided with Ipopt.jl will increase the runtime by 2-6x.","category":"page"},{"location":"experiment-results/#Software-Versions","page":"Experiment Results","title":"Software Versions","text":"","category":"section"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"PowerModels.jl: v0.17","category":"page"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"Ipopt.jl: v0.6","category":"page"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"PGLib-OPF: v19.05","category":"page"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"Hardware: Dual Intel 2.10GHz CPUs, 128GB RAM","category":"page"},{"location":"experiment-results/#Typical-Operating-Conditions-(TYP)","page":"Experiment Results","title":"Typical Operating Conditions (TYP)","text":"","category":"section"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"Case Name Nodes Edges AC ($/h) QC Gap (%) SOC Gap (%) AC Time (sec.) QC Time (sec.) SOC Time (sec.)\ncase3_lmbd 3 3 5.8126e+03 1.22 1.32 <1 <1 <1\ncase5_pjm 5 6 1.7552e+04 14.55 14.55 <1 <1 <1\ncase14_ieee 14 20 2.1781e+03 0.11 0.11 <1 <1 <1\ncase24_ieee_rts 24 38 6.3352e+04 0.02 0.02 <1 <1 <1\ncase30_as 30 41 8.0313e+02 0.06 0.06 <1 <1 <1\ncase30_fsr 30 41 5.7577e+02 0.39 0.39 <1 <1 <1\ncase30_ieee 30 41 8.2085e+03 18.81 18.84 <1 <1 <1\ncase39_epri 39 46 1.3842e+05 0.55 0.56 <1 <1 <1\ncase57_ieee 57 80 3.7589e+04 0.16 0.16 <1 <1 <1\ncase73_ieee_rts 73 120 1.8976e+05 0.04 0.04 <1 <1 <1\ncase89_pegase 89 210 1.0729e+05 0.75 0.75 <1 <1 <1\ncase118_ieee 118 186 9.7214e+04 0.79 0.91 <1 <1 <1\ncase162_ieee_dtc 162 284 1.0808e+05 5.84 5.95 <1 <1 <1\ncase179_goc 179 263 7.5427e+05 0.16 0.16 <1 <1 <1\ncase200_tamu 200 245 2.7558e+04 0.01 0.01 <1 <1 <1\ncase240_pserc 240 448 3.3297e+06 2.73 2.78 3 4 2\ncase300_ieee 300 411 5.6522e+05 2.58 2.63 <1 <1 <1\ncase500_tamu 500 597 7.2578e+04 5.39 5.39 <1 2 <1\ncase588_sdet 588 686 3.1314e+05 1.91 2.14 <1 2 <1\ncase1354_pegase 1354 1991 1.2588e+06 1.56 1.57 5 6 3\ncase1888_rte 1888 2531 1.4025e+06 2.05 2.05 9 8 31\ncase1951_rte 1951 2596 2.0856e+06 0.13 0.14 19 9 5\ncase2000_tamu 2000 3206 1.2285e+06 0.20 0.21 10 9 3\ncase2316_sdet 2316 3017 1.7753e+06 1.79 1.80 6 11 4\ncase2383wp_k 2383 2896 1.8682e+06 0.97 1.04 7 10 5\ncase2736sp_k 2736 3504 1.3080e+06 0.30 0.31 6 10 4\ncase2737sop_k 2737 3506 7.7773e+05 0.26 0.27 5 8 3\ncase2746wop_k 2746 3514 1.2083e+06 0.36 0.37 5 9 4\ncase2746wp_k 2746 3514 1.6317e+06 0.32 0.33 6 9 4\ncase2848_rte 2848 3776 1.2866e+06 0.12 0.13 17 13 7\ncase2853_sdet 2853 3921 2.0524e+06 0.87 0.91 9 12 6\ncase2868_rte 2868 3808 2.0096e+06 0.10 0.10 15 14 8\ncase2869_pegase 2869 4582 2.4628e+06 1.01 1.01 11 20 7\ncase3012wp_k 3012 3572 2.6008e+06 0.98 1.03 9 14 13\ncase3120sp_k 3120 3693 2.1480e+06 0.55 0.56 9 12 5\ncase3375wp_k 3374 4161 7.4382e+06 0.54 0.55 11 29 6\ncase4661_sdet 4661 5997 2.2513e+06 1.89 1.99 15 27 12\ncase6468_rte 6468 9000 2.0697e+06 1.12 1.13 64 87 27\ncase6470_rte 6470 9005 2.2376e+06 1.75 1.76 36 43 24\ncase6495_rte 6495 9019 3.0678e+06 15.09 15.11 69 65 25\ncase6515_rte 6515 9037 2.8255e+06 6.39 6.40 53 44 23\ncase9241_pegase 9241 16049 6.2431e+06 1.71 2.54 49 104 36\ncase10000_tamu 10000 12706 2.4859e+06 0.37 0.72 98 67 33\ncase13659_pegase 13659 20467 8.9480e+06 0.98 1.39 59 121 62","category":"page"},{"location":"experiment-results/#Congested-Operating-Conditions-(API)","page":"Experiment Results","title":"Congested Operating Conditions (API)","text":"","category":"section"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"Case Name Nodes Edges AC ($/h) QC Gap (%) SOC Gap (%) AC Time (sec.) QC Time (sec.) SOC Time (sec.)\ncase3_lmbd__api 3 3 1.1242e+04 5.63 9.32 <1 <1 <1\ncase5_pjm__api 5 6 7.6377e+04 4.09 4.09 <1 <1 <1\ncase14_ieee__api 14 20 5.9994e+03 5.13 5.13 <1 <1 <1\ncase24_ieee_rts__api 24 38 1.3495e+05 13.01 17.87 <1 <1 <1\ncase30_as__api 30 41 4.9962e+03 44.61 44.61 <1 <1 <1\ncase30_fsr__api 30 41 7.0115e+02 2.76 2.76 <1 <1 <1\ncase30_ieee__api 30 41 1.8044e+04 5.46 5.46 <1 <1 <1\ncase39_epri__api 39 46 2.4975e+05 1.72 1.74 <1 <1 <1\ncase57_ieee__api 57 80 4.9297e+04 0.09 0.09 <1 <1 <1\ncase73_ieee_rts__api 73 120 4.2273e+05 11.07 12.89 <1 <1 <1\ncase89_pegase__api 89 210 1.3428e+05 13.45 13.47 <1 <1 <1\ncase118_ieee__api 118 186 2.4205e+05 28.70 28.81 <1 <1 <1\ncase162_ieee_dtc__api 162 284 1.2100e+05 4.33 4.36 <1 <1 <1\ncase179_goc__api 179 263 1.9321e+06 5.93 9.88 <1 2 <1\ncase200_tamu__api 200 245 3.6763e+04 0.03 0.03 <1 <1 <1\ncase240_pserc__api 240 448 4.7681e+06 0.69 0.74 4 5 2\ncase300_ieee__api 300 411 6.5015e+05 0.84 0.89 <1 <1 <1\ncase500_tamu__api 500 597 4.2776e+04 2.92 2.92 <1 2 <1\ncase588_sdet__api 588 686 3.9476e+05 1.39 1.61 <1 2 <1\ncase1354_pegase__api 1354 1991 1.4867e+06 0.65 0.66 5 7 3\ncase1888_rte__api 1888 2531 1.9539e+06 0.22 0.23 8 15 6\ncase1951_rte__api 1951 2596 2.4168e+06 0.53 0.55 9 9 5\ncase2000_tamu__api 2000 3206 1.2850e+06 2.66 2.71 13 10 3\ncase2316_sdet__api 2316 3017 2.1890e+06 1.79 1.80 8 11 4\ncase2383wp_k__api 2383 2896 2.7913e+05 0.01 0.01 2 3 <1\ncase2736sp_k__api 2736 3504 6.5394e+05 10.83 10.84 7 9 3\ncase2737sop_k__api 2737 3506 3.6920e+05 6.41 6.41 6 4 2\ncase2746wop_k__api 2746 3514 5.1166e+05 0.01 0.01 2 3 2\ncase2746wp_k__api 2746 3514 5.8183e+05 0.01 0.00 3 5 2\ncase2848_rte__api 2848 3776 1.4760e+06 0.25 0.25 28 13 6\ncase2853_sdet__api 2853 3921 2.4579e+06 1.92 1.96 10 13 6\ncase2868_rte__api 2868 3808 2.3405e+06 0.18 0.19 26 15 6\ncase2869_pegase__api 2869 4582 2.9342e+06 1.32 1.33 13 19 8\ncase3012wp_k__api 3012 3572 7.2887e+05 0.00 0.00 4 5 2\ncase3120sp_k__api 3120 3693 9.8428e+05 23.54 23.60 12 13 4\ncase3375wp_k__api 3374 4161 5.8478e+06 9.35 – 11 22 347\ncase4661_sdet__api 4661 5997 2.6951e+06 2.54 2.64 17 27 50\ncase6468_rte__api 6468 9000 2.3135e+06 0.80 0.82 76 55 190\ncase6470_rte__api 6470 9005 2.6065e+06 1.19 1.20 55 38 68\ncase6495_rte__api 6495 9019 3.0265e+06 2.97 3.01 55 46 23\ncase6515_rte__api 6515 9037 3.1363e+06 1.91 1.95 63 46 22\ncase9241_pegase__api 9241 16049 7.0264e+06 1.80 – 118 262 1617\ncase10000_tamu__api 10000 12706 1.8713e+06 5.53 6.18 108 117 34\ncase13659_pegase__api 13659 20467 9.2971e+06 1.18 1.83 65 164 76","category":"page"},{"location":"experiment-results/#Small-Angle-Difference-Conditions-(SAD)","page":"Experiment Results","title":"Small Angle Difference Conditions (SAD)","text":"","category":"section"},{"location":"experiment-results/","page":"Experiment Results","title":"Experiment Results","text":"Case Name Nodes Edges AC ($/h) QC Gap (%) SOC Gap (%) AC Time (sec.) QC Time (sec.) SOC Time (sec.)\ncase3_lmbd__sad 3 3 5.9593e+03 1.42 3.75 <1 <1 <1\ncase5_pjm__sad 5 6 2.6115e+04 0.99 3.62 <1 <1 <1\ncase14_ieee__sad 14 20 2.7773e+03 21.50 21.54 <1 <1 <1\ncase24_ieee_rts__sad 24 38 7.6943e+04 2.93 9.56 <1 <1 <1\ncase30_as__sad 30 41 8.9749e+02 2.32 7.88 <1 <1 <1\ncase30_fsr__sad 30 41 5.7679e+02 0.41 0.47 <1 <1 <1\ncase30_ieee__sad 30 41 8.2085e+03 5.93 9.70 <1 <1 <1\ncase39_epri__sad 39 46 1.4835e+05 0.21 0.66 <1 <1 <1\ncase57_ieee__sad 57 80 3.8664e+04 0.35 0.71 <1 <1 <1\ncase73_ieee_rts__sad 73 120 2.2775e+05 2.54 6.75 <1 <1 <1\ncase89_pegase__sad 89 210 1.0729e+05 0.71 0.73 <1 <1 <1\ncase118_ieee__sad 118 186 1.0522e+05 6.84 8.22 <1 <1 <1\ncase162_ieee_dtc__sad 162 284 1.0870e+05 6.25 6.48 <1 <1 <1\ncase179_goc__sad 179 263 7.6254e+05 1.01 1.12 <1 <1 <1\ncase200_tamu__sad 200 245 2.7558e+04 0.01 0.01 <1 <1 <1\ncase240_pserc__sad 240 448 3.4071e+06 4.41 4.98 4 4 2\ncase300_ieee__sad 300 411 5.6571e+05 2.43 2.61 <1 <1 <1\ncase500_tamu__sad 500 597 7.9234e+04 7.90 7.92 <1 2 <1\ncase588_sdet__sad 588 686 3.2986e+05 6.10 6.81 <1 2 <1\ncase1354_pegase__sad 1354 1991 1.2588e+06 1.53 1.57 5 6 3\ncase1888_rte__sad 1888 2531 1.4139e+06 2.81 2.82 9 8 24\ncase1951_rte__sad 1951 2596 2.0928e+06 0.44 0.48 17 9 5\ncase2000_tamu__sad 2000 3206 1.2303e+06 0.33 0.35 10 9 3\ncase2316_sdet__sad 2316 3017 1.7753e+06 1.76 1.80 6 10 5\ncase2383wp_k__sad 2383 2896 1.9127e+06 1.98 2.93 8 10 5\ncase2736sp_k__sad 2736 3504 1.3273e+06 1.36 1.63 8 10 5\ncase2737sop_k__sad 2737 3506 7.9153e+05 1.76 1.95 7 9 4\ncase2746wop_k__sad 2746 3514 1.2343e+06 2.01 2.37 7 8 4\ncase2746wp_k__sad 2746 3514 1.6676e+06 1.67 2.22 8 9 5\ncase2848_rte__sad 2848 3776 1.2890e+06 0.24 0.26 17 13 6\ncase2853_sdet__sad 2853 3921 2.0701e+06 1.69 1.74 9 11 6\ncase2868_rte__sad 2868 3808 2.0224e+06 0.61 0.64 18 13 6\ncase2869_pegase__sad 2869 4582 2.4689e+06 1.02 1.13 11 20 7\ncase3012wp_k__sad 3012 3572 2.6213e+06 1.41 1.62 10 14 6\ncase3120sp_k__sad 3120 3693 2.1782e+06 1.51 1.65 11 14 6\ncase3375wp_k__sad 3374 4161 7.4382e+06 0.50 0.55 11 18 6\ncase4661_sdet__sad 4661 5997 2.2610e+06 1.79 1.96 16 27 12\ncase6468_rte__sad 6468 9000 2.0697e+06 1.10 1.12 63 75 31\ncase6470_rte__sad 6470 9005 2.2416e+06 1.87 1.91 37 42 22\ncase6495_rte__sad 6495 9019 3.0678e+06 14.99 15.11 70 56 25\ncase6515_rte__sad 6515 9037 2.8826e+06 8.22 8.26 61 46 22\ncase9241_pegase__sad 9241 16049 6.3195e+06 2.42 2.48 59 91 35\ncase10000_tamu__sad 10000 12706 2.4859e+06 0.36 0.72 59 68 36\ncase13659_pegase__sad 13659 20467 9.0433e+06 1.64 1.69 57 125 43","category":"page"},{"location":"network-data/#PowerModels-Network-Data-Format","page":"Network Data Format","title":"PowerModels Network Data Format","text":"","category":"section"},{"location":"network-data/#The-Network-Data-Dictionary","page":"Network Data Format","title":"The Network Data Dictionary","text":"","category":"section"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Internally PowerModels utilizes a dictionary to store network data. The dictionary uses strings as key values so it can be serialized to JSON for algorithmic data exchange.","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"The data dictionary organization and key names are designed to be mostly consistent with the Matpower file format and should be familiar to power system researchers, with the notable exceptions that loads and shunts are now split into separate components (see example below), and in the case of \"multinetwork\" data, most often used for time series.","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Following the conventions of the InfrastructureModels ecosystem, all PowerModels components have the following standard parameters unless noted otherwise:","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"\"index\":<int> the component's unique integer id, which is also its lookup id\n\"status\":<int> a {1,0} flag that determines if the component is active or not, respectively.\n(\"name\":<string>) a human readable name for the component\n(\"source_id\":<vector{string}>) a list of string data forming a unique id from a source data format","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"The PowerModels network data dictionary structure is roughly as follows:","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"{\n\"per_unit\":<boolean>,            # A boolean value indicating if the component parameters are in mixed-units or per unit (p.u.)\n\"baseMVA\":<float, MVA>,          # The system wide MVA value for converting between mixed-units and p.u. unit values\n(\"time_elapsed\":<float, hours>,) # An amount of time that has passed, used to computing time integrals in storage models\n(\"multinetwork\":<boolean>,)      # A boolean value indicating if the data represents a single network or multiple networks (assumed `false` when not present)\n(\"name\":<string>,)               # A human readable name for the network data\n(\"description\":<string>,)        # A textual description of the network data and any other related notes\n(\"source_type\":<string>,)        # The type of source data that generated this data\n(\"source_version\":<string>,)     # The version of source data, if applicable\n\"bus\":{\n    \"1\":{\n        \"va\":<float, radians>,  # Voltage angle\n        \"vm\":<float, V p.u.>,   # Voltage magnitude\n        \"vmin\":<float, V p.u.>, # A minimum voltage magnitude\n        \"vmax\":<float, V p.u.>, # A maximum voltage magnitude\n        \"bus_type\":<int>,       # Bus status field inactive if 4, active otherwise; also used in power flow studies\n        ...\n    },\n    \"2\":{...},\n    ...\n},\n\"load\":{\n    \"1\":{\n        \"load_bus\":<int>,   # Index of the bus to which the load is attached\n        \"pd\":<float, MW>,   # Active power withdrawn\n        \"qd\":<float, MVar>, # Reactive power withdrawn\n        ...\n    },\n    \"2\":{...},\n    ...\n},\n\"shunt\":{\n    \"1\":{\n        \"shunt_bus\":<int>, # Index of the bus to which the shunt is attached\n        \"gs\":<float>,      # Active power withdrawn per voltage p.u.\n        \"bs\":<float>,      # Reactive power withdrawn per voltage p.u.\n        ...\n    },\n    \"2\":{...},\n    ...\n},\n\"gen\":{\n    \"1\":{\n        \"gen_bus\":<int>,       # Index of the bus to which the generator is attached\n        \"pg\":<float, MW>,      # Active power injected\n        \"qg\":<float, MVAr>,    # Reactive power injected\n        \"pmin\":<float, MW>,    # Active power lower bound\n        \"pmax\":<float, MW>,    # Active power upper bound\n        \"qmin\":<float, MVAr>,  # Reactive power lower bound\n        \"qmax\":<float, MVAr>,  # Reactive power upper bound\n        \"gen_status\":<int>,    # Status flag for generators\n        (\"model\":<int>,)       # Cost model 1=piecewise linear, 2=polynomial\n        (\"ncost\":<int>,)       # Length of cost model data\n        (\"cost\"<vector{float}, $MWh>:) # Cost model data\n        ...\n    },\n    \"2\":{...},\n    ...\n},\n\"storage\":{\n    \"1\":{\n        \"storage_bus\":<int>,             # Index of the bus to which the storage is attached\n        \"ps\":<float, MW>,                # Active power withdrawn\n        \"qs\":<float, MVAr>,              # Reactive power withdrawn\n        \"energy\":<float, MWh>,           # Amount of stored energy\n        \"energy_rating\":<float, MWh>,    # Maximum amount of stored energy\n        \"charge_rating\":<float, MW>,     # Maximum amount of charge per unit time\n        \"discharge_rating\":<float, MW>,  # Maximum amount of discharge per unit time\n        \"charge_efficiency\":<float>,     # Relative efficiency when charging (between 0.0 and 1.0)\n        \"discharge_efficiency\":<float>,  # Relative efficiency when discharging (between 0.0 and 1.0)\n        \"qmin\":<float, MVar>,            # Reactive power lower bound\n        \"qmax\":<float, MVar>,            # Reactive power upper bound\n        \"r\":<float, p.u.>,               # Power inverter resistance\n        \"x\":<float, p.u.>,               # Power inverter reactance\n        \"p_loss\":<float, MW>,            # Active power standby losses\n        \"q_loss\":<float, MVar>,          # Reactive power standby losses\n        (\"thermal_rating\":<float, MVA>,) # Apparent power withdrawn limit\n        (\"current_rating\":<float, MA>,)  # Current magnitude withdrawn limit\n        ...\n    },\n    \"2\":{...},\n    ...\n},\n\"branch\":{\n    \"1\":{\n        \"f_bus\":<int>,               # Index of the from bus to which the branch is attached\n        \"t_bus\":<int>,               # Index of the to bus to which the branch is attached\n        \"br_r\":<float, p.u.>,        # Branch series resistance\n        \"br_x\":<float, p.u.>,        # Branch series reactance\n        \"tap\": <float, p.u.>,        # Branch off nominal turns ratio\n        \"shift\": <float, radians>,   # Branch phase shift angle\n        \"g_fr\":<float, p.u.>,        # Line charging conductance at from bus\n        \"b_fr\":<float, p.u.>,        # Line charging susceptance at from bus\n        \"g_to\":<float, p.u.>,        # Line charging conductance at to bus\n        \"b_to\":<float, p.u.>,        # Line charging susceptance at to bus\n        \"transformer\":<boolean>,     # Status flag indicating if the branch is a transformer\n        \"br_status\":<int>,           # Status flag for branches\n        (\"rate_a\":<float, MVA>,)     # Long term thermal line rating\n        (\"rate_b\":<float, MVA>,)     # Short term thermal line rating\n        (\"rate_c\":<float, MVA>,)     # Emergency thermal line rating\n        (\"angmin\": <float, radians>, # Minimum angle difference between the from and to buses\n        (\"angmax\": <float, radians>, # Maximum angle difference between the from and to buses\n        (\"c_rating_a\":<float, MA>,)  # Long term current line rating\n        (\"c_rating_b\":<float, MA>,)  # Short term current line rating\n        (\"c_rating_c\":<float, MA>,)  # Emergency current line rating\n        (\"pf\":<float, MW>,)          # Active power withdrawn at the from bus\n        (\"qf\":<float, MVAr>,)        # Reactive power withdrawn at the from bus\n        (\"pt\":<float, MW>,)          # Active power withdrawn at the to bus\n        (\"qt\":<float, MVAr>,)        # Reactive power withdrawn at the to bus\n        ...\n    },\n    \"2\":{...},\n    ...\n},\n\"dcline\":{\n    \"1\":{\n        \"f_bus\":<int>,          # Index of the from bus to which the dcline is attached\n        \"t_bus\":<int>,          # Index of the to bus to which the dcline is attached\n        \"pminf\":<float, MW>,    # Active power lower bound at the from bus\n        \"pmaxf\":<float, MW>,    # Active power upper bound at the from bus\n        \"qminf\":<float, MVAr>,  # Reactive power lower bound at the from bus\n        \"qmaxf\":<float, MVAr>,  # Reactive power upper bound at the from bus\n        \"pmint\":<float, MW>,    # Active power lower bound at the to bus\n        \"pmaxt\":<float, MW>,    # Active power upper bound at the to bus\n        \"qmint\":<float, MVAr>,  # Reactive power lower bound at the to bus\n        \"qmaxt\":<float, MVAr>,  # Reactive power upper bound at the to bus\n        \"loss0\":<float>,        # Constant active power loss term linking the from and to buses\n        \"loss1\":<float>,        # Linear active power loss term linking the from and to buses\n        \"br_status\":<int>,      # Status flag for dclines\n        (\"pf\":<float, MW>,)     # Active power withdrawn at the from bus\n        (\"qf\":<float, MVAr>,)   # Reactive power withdrawn at the from bus\n        (\"pt\":<float, MW>,)     # Active power withdrawn at the to bus\n        (\"qt\":<float, MVAr>,)   # Reactive power withdrawn at the to bus\n        (\"vf\":<float, V p.u.>,) # Voltage set-point at the from bus\n        (\"vt\":<float, V p.u.>,) # Voltage set-point at the to bus\n        (\"model\":<int>,)        # Cost model 1=piecewise linear, 2=polynomial\n        (\"ncost\":<int>,)        # Length of cost model data\n        (\"cost\"<vector{float}, $MWh>:) # Cost model data\n        ...\n    },\n    \"2\":{...},\n    ...\n},\n\"switch\":{\n    \"1\":{\n        \"f_bus\":<int>,                   # Index of the from bus to which the switch is attached\n        \"t_bus\":<int>,                   # Index of the to bus to which the switch is attached\n        \"state\":<int>,                   # A {0,1} flag that determines if the switch is open or closed, respectively.\n        (\"thermal_rating\":<float, MVA>,) # Apparent power flow limit\n        (\"current_rating\":<float, MA>,)  # Current magnitude flow limit\n        (\"psw\":<float, MW>,)             # Active power withdrawn at the from bus\n        (\"qsw\":<float, MVar>,)           # Reactive power withdrawn at the from bus\n        ...\n    },\n    \"2\":{...},\n    ...\n},\n...\n}","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"The following commands can be used to explore the network data dictionary generated by a given PTI or Matpower (this example) data file,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"network_data = PowerModels.parse_file(\"matpower/case3.m\")\ndisplay(network_data) # raw dictionary\nPowerModels.print_summary(network_data) # quick table-like summary\nPowerModels.component_table(network_data, \"bus\", [\"vmin\", \"vmax\"]) # component data in matrix form","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"The print_summary function generates a table-like text summary of the network data, which is helpful in quickly assessing the values in a data or solution dictionary.  The component_table builds a matrix of data for a given component type where there is one row for each component and one column for each requested data field.  The first column of a component table is the component's identifier (i.e. the index).","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"For a detailed list of all possible parameters refer to the specification document provided with Matpower. The exception to this is that \"load\" and \"shunt\", containing \"pd\", \"qd\" and \"gs\", \"bs\", respectively, have been added as additional fields. These values are contained in \"bus\" in the original specification.","category":"page"},{"location":"network-data/#Noteworthy-Differences-from-Matpower-Data-Files","page":"Network Data Format","title":"Noteworthy Differences from Matpower Data Files","text":"","category":"section"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"The PowerModels network data dictionary differs from the Matpower format in the following ways,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"All PowerModels components have an index parameter, which can be used to uniquely identify that network element.\nAll network parameters are in per-unit and angles are in radians.\nAll non-transformer branches are given nominal transformer values (i.e. a tap of 1.0 and a shift of 0.0).\nAll branches have a transformer field indicating if they are a transformer or not.\nThermal limit (rate) and current (c_rating) ratings on branches are optional.\nWhen present, the gencost data is incorporated into the gen data, the column names remain the same.\nWhen present, the dclinecost data is incorporated into the dcline data, the column names remain the same.\nWhen present, the bus_names data is incorporated into the bus data under the property \"bus_name\".\nSpecial treatment is given to the optional ne_branch matrix to support the TNEP problem.\nLoad data are split off from bus data into load data under the same property names.\nShunt data are split off from bus data into shunt data under the same property names.","category":"page"},{"location":"network-data/#Working-with-the-Network-Data-Dictionary","page":"Network Data Format","title":"Working with the Network Data Dictionary","text":"","category":"section"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Data exchange via JSON files is ideal for building algorithms, however it is hard to for humans to read and process.  To that end PowerModels provides various helper functions for manipulating the network data dictionary.","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"The first of these helper functions are make_per_unit and make_mixed_units!, which convert the units of the data inside a network data dictionary.  The mixed units format follows the unit conventions from Matpower and other common power network formats where some of the values are in per unit and others are the true values.  These functions can be used as follows,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"network_data = PowerModels.parse_file(\"matpower/case3.m\")\nPowerModels.print_summary(network_data) # default per-unit form\nPowerModels.make_mixed_units!(network_data)\nPowerModels.print_summary(network_data) # mixed units form","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Another useful helper function is update_data, which takes two network data dictionaries and updates the values in the first dictionary with the values from the second dictionary.  This is particularly helpful when applying sparse updates to network data.  A good example is using the solution of one computation to update the data in preparation for a second computation, like so,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"data = PowerModels.parse_file(\"matpower/case3.m\")\nopf_result = solve_ac_opf(data, Ipopt.Optimizer)\nPowerModels.print_summary(opf_result[\"solution\"])\n\nPowerModels.update_data!(data, opf_result[\"solution\"])\npf_result = solve_ac_pf(data, Ipopt.Optimizer)\nPowerModels.print_summary(pf_result[\"solution\"])","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"A variety of helper functions are available for processing the topology of the network.  For example, connected_components will compute the collections of buses that are connected by branches (i.e. the network's islands).  By default PowerModels will attempt to solve all of the network components simultaneously.  The select_largest_component function can be used to only consider the largest component in the network.  Finally the propagate_topology_status! can be used to explicitly deactivate components that are implicitly inactive due to the status of other components (e.g. deactivating branches based on the status of their connecting buses), like so,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"data = PowerModels.parse_file(\"matpower/case3.m\")\nPowerModels.propagate_topology_status!(data)\nopf_result = solve_ac_opf(data, Ipopt.Optimizer)","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"The test/data/matpower/case7_tplgy.m case provides an example of the kind of component status deductions that can be made.  The simplify_network!, propagate_topology_status! and deactivate_isolated_components! functions can be helpful in diagnosing network models that do not converge or have an infeasible solution.","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"For details on all of the network data helper functions see, src/core/data.jl.","category":"page"},{"location":"network-data/#Working-with-Matpower-Data-Files","page":"Network Data Format","title":"Working with Matpower Data Files","text":"","category":"section"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"PowerModels has extensive support for parsing Matpower network files in the .m format.","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"In addition to parsing the standard Matpower parameters, PowerModels also supports extending the standard Matpower format in a number of ways as illustrated by the following examples.  In these examples JSON document fragments are used to indicate the structure of the PowerModel dictionary.","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Note that for DC lines, the flow results are returned using the same convention as for the AC lines, i.e. positive values for p_from/q_fromand p_to/q_to indicating power flow from the 'to' node or 'from' node into the line. This means that w.r.t matpower the sign is identical for p_from, but opposite for q_from/p_to/q_to.","category":"page"},{"location":"network-data/#Single-Values","page":"Network Data Format","title":"Single Values","text":"","category":"section"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Single values are added to the root of the dictionary as follows,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"mpc.const_float = 4.56","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"becomes","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"{\n\"const_float\": 4.56\n}","category":"page"},{"location":"network-data/#Nonstandard-Matrices","page":"Network Data Format","title":"Nonstandard Matrices","text":"","category":"section"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Nonstandard matrices can be added as follows,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"mpc.areas = [\n    1   1;\n    2   3;\n];","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"becomes","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"{\n\"areas\":{\n    \"1\":{\n        \"index\":1,\n        \"col_1\":1,\n        \"col_2\":1\n    },\n    \"2\":{\n        \"index\":1,\n        \"col_1\":2,\n        \"col_2\":3\n    }\n}\n}","category":"page"},{"location":"network-data/#Column-Names","page":"Network Data Format","title":"Column Names","text":"","category":"section"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Column names can be given to nonstandard matrices using the following special comment,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"%column_names%  area    refbus\nmpc.areas_named = [\n    4   5;\n    5   6;\n];","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"becomes","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"{\n\"areas\":{\n    \"1\":{\n        \"index\":1,\n        \"area\":4,\n        \"refbus\":5\n    },\n    \"2\":{\n        \"index\":2,\n        \"area\":5,\n        \"refbus\":6\n    }\n}\n}","category":"page"},{"location":"network-data/#Standard-Matrix-Extensions","page":"Network Data Format","title":"Standard Matrix Extensions","text":"","category":"section"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Finally, if a nonstandard matrix's name extends a current Matpower matrix name with an underscore, then its values will be merged with the original Matpower component data.  Note that this feature requires that the nonstandard matrix has column names and has the same number of rows as the original matrix (similar to the gencost matrix in the Matpower format).  For example,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"%column_names%  rate_i  rate_p\nmpc.branch_limit = [\n    50.2    45;\n    36  60.1;\n    12  30;\n];","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"becomes","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"{\n\"branch\":{\n    \"1\":{\n        \"index\":1,\n        ...(all pre existing fields)...\n        \"rate_i\":50.2,\n        \"rate_p\":45\n    },\n    \"2\":{\n        \"index\":2,\n        ...(all pre existing fields)...\n        \"rate_i\":36,\n        \"rate_p\":60.1\n    },\n    \"3\":{\n        \"index\":3,\n        ...(all pre existing fields)...\n        \"rate_i\":12,\n        \"rate_p\":30\n    }\n}\n}","category":"page"},{"location":"network-data/#Working-with-PTI-Data-files","page":"Network Data Format","title":"Working with PTI Data files","text":"","category":"section"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"PowerModels also has support for parsing PTI network files in the .raw format that follow the PSS(R)E v33 specification.  Currently PowerModels supports the following PTI components,","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"Buses\nLoads (constant power)\nFixed Shunts\nSwitch Shunts (default configuration)\nGenerators\nBranches\nTransformers (two and three winding)\nTwo-Terminal HVDC Lines (approximate)\nVoltage Source Converter HVDC Lines (approximate)","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"In addition to parsing the standard parameters required by PowerModels for calculations, PowerModels also supports parsing additional data fields that are defined by the PSS(R)E specification, but not used by PowerModels directly. This can be achieved via the import_all optional keyword argument in parse_file when loading a .raw file, e.g.","category":"page"},{"location":"network-data/","page":"Network Data Format","title":"Network Data Format","text":"PowerModels.parse_file(\"pti/case3.raw\"; import_all=true)","category":"page"},{"location":"developer/#Developer-Documentation","page":"Developer","title":"Developer Documentation","text":"","category":"section"},{"location":"developer/#Function-Naming-Guidelines","page":"Developer","title":"Function Naming Guidelines","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Following the Julia style guidelines, functions that mutate arguments should end with !.  Following the JuMP style guidelines functions beginning with an _ are intended for internal package use only (i.e. similar private  scope functions).  Underscores are used to separate multi-word function names and the words should typically be ordered from general to more specific, so that alphabetical sorting clusters similar functions together.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Due to model-agnostic design of PowerModels, top level functions are implicitly defined on complex numbers.  Specializations of these functions yield different complex coordinates systems and real-valued model parameters.  ","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Top level functions have the following structure,","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"<variable|constraint>_<component short name>_<quantity name>(_fr|_to)(_on_off)","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The suffixes have the following meanings,","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"_fr: the from-side of a two-terminal component (e.g., branch or switch)\n_to: the to-side of a two-terminal component (e.g., branch or switch)\n_on_off: indicates that the constraint can be added or removed with a discrete 0-1 indicator variable.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Note that the from-to orientation of two-terminal components is often arbitrary and does not imply a direction of flow.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The most common values of <quantity name> are power, current and voltage.  Compound names like voltage_product are also possible.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Lower level functions have the following structure,","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"<variable|constraint>_<component short name>_<quantity name>\n(_real|_imaginary|_magnitude|_angle|_factor)(_fr|_to)(_sqr)(_on_off)","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The additional suffixes have the following meanings,","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"_real: the real component of a complex value in rectangular coordinates\n_imaginary: the imaginary component of a complex value in rectangular coordinates\n_magnitude: the magnitude of a complex value in polar coordinates\n_angle: the angle of a complex value in polar coordinates\n_factor: a continuous real value (usually in the range 0.0 to 1.0), that scales a complex value in equal proportions\n_sqr: the square of a value, usually paired with _magnitude","category":"page"},{"location":"developer/#Special-Cases","page":"Developer","title":"Special Cases","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"In the interest of intuitive names for users, the following special cases are also acceptable,","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The value of <component short name> can be omitted from constraint definitions for one of the canonical components that it applies to.\n_power_real -(can be replaced with)-> _active\n_power_imaginary -(can be replaced with)-> _reactive","category":"page"},{"location":"developer/#Variable-and-Parameter-Naming-Guidelines","page":"Developer","title":"Variable and Parameter Naming Guidelines","text":"","category":"section"},{"location":"developer/#Power","page":"Developer","title":"Power","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Defining power s = p + j cdot q and sm = s","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"s: complex power (VA)\nsm: apparent power (VA)\np: active power (W)\nq: reactive power (var)","category":"page"},{"location":"developer/#Voltage","page":"Developer","title":"Voltage","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Defining voltage v = vm angle va = vr + j cdot vi:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"vm: magnitude of (complex) voltage (V)\nva: angle of complex voltage (rad)\nvr: real part of (complex) voltage (V)\nvi: imaginary part of complex voltage (V)","category":"page"},{"location":"developer/#Current","page":"Developer","title":"Current","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Defining current c = cm angle ca = cr + j cdot ci:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"cm: magnitude of (complex) current (A)\nca: angle of complex current (rad)\ncr: real part of (complex) current (A)\nci: imaginary part of complex current (A)","category":"page"},{"location":"developer/#Voltage-products","page":"Developer","title":"Voltage products","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Defining voltage product w = v_i cdot v_j then w = wm angle wa = wr + jcdot wi:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"wm (short for vvm): magnitude of (complex) voltage products (V^2)\nwa (short for vva): angle of complex voltage products (rad)\nwr (short for vvr): real part of (complex) voltage products (V^2)\nwi (short for vvi): imaginary part of complex voltage products (V^2)","category":"page"},{"location":"developer/#Current-products","page":"Developer","title":"Current products","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Defining current product cc = c_i cdot c_j then cc = ccm angle cca = ccr + jcdot cci:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"ccm: magnitude of (complex) current products (A^2)\ncca: angle of complex current products (rad)\nccr: real part of (complex) current products (A^2)\ncci: imaginary part of complex current products (A^2)","category":"page"},{"location":"developer/#Transformer-ratio","page":"Developer","title":"Transformer ratio","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Defining complex transformer ratio t = tm angle ta = tr + jcdot ti:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"tm: magnitude of (complex) transformer ratio (-)\nta: angle of complex transformer ratio (rad)\ntr: real part of (complex) transformer ratio (-)\nti: imaginary part of complex transformer ratio (-)","category":"page"},{"location":"developer/#Impedance","page":"Developer","title":"Impedance","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Defining impedance z = r + jcdot x:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"r: resistance (Omega)\nx: reactance (Omega)","category":"page"},{"location":"developer/#Admittance","page":"Developer","title":"Admittance","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Defining admittance y = g + jcdot b:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"g: conductance (S)\nb: susceptance (S)","category":"page"},{"location":"developer/#Standard-Value-Names","page":"Developer","title":"Standard Value Names","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"network ids:network, nw, n\nconductors ids: conductor, cnd, c\nphase ids: phase, ph, h","category":"page"},{"location":"developer/#DistFlow-Derivation","page":"Developer","title":"DistFlow Derivation","text":"","category":"section"},{"location":"developer/#For-an-asymmetric-pi-section","page":"Developer","title":"For an asymmetric pi section","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Following notation of [1], but recognizing it derives the SOC BFM without shunts. In a pi-section, part of the total current I_lij at the from side flows  through the series impedance, I^s_lij, part of it flows through the from side shunt admittance I^sh_lij. Vice versa for the to-side. Indicated by superscripts 's' (series) and 'sh' (shunt).","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign\n mboxOhms law   U^mag_j angle theta_j = U^mag_iangle theta_i  - z^s_lij cdot I^s_lij nonumber \n mboxKCL at shunts   I_lij = I^s_lij + I^sh_lij I_lji = I^s_lji + I^sh_lji nonumber \n mboxObserving   Observing I^s_lij = - I^s_lji vert I^s_lij vert = vert I^s_lji vert nonumber \n mboxOhms law times its own complex conjugate  (U^mag_j)^2 = (U^mag_iangle theta_i  - z^s_lij cdot I^s_lij)cdot (U^mag_iangle theta_i  - z^s_lij cdot I^s_lij)^* nonumber \n mboxDefining  S^s_lij = P^s_lij + jcdot Q^s_lij = (U^mag_iangle theta_i) cdot (I^s_lij)^* nonumber \n mboxWorking it out  (U^mag_j)^2 = (U^mag_i)^2 - 2 cdot(r^s_lij cdot P^s_lij + x^s_lij cdot Q^s_lij)  + ((r^s_lij)^2 + (x^s_lij)^2)vert I^s_lij vert^2 nonumber \nendalign","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Power flow balance w.r.t. branch total losses","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign\n mboxActive power flow  P_lij + P_lji = g^sh_lij cdot (U^mag_i)^2 + r^s_l cdot vert I^s_lij vert^2 +  g^sh_lji cdot (U^mag_j)^2 nonumber \n mboxReactive power flow  Q_lij + Q_lji = -b^sh_lij cdot (U^mag_i)^2 + x^s_l cdot vert I^s_lij vert^2  - b^sh_lji cdot (U^mag_j)^2 nonumber \n mboxCurrent definition  vert S^s_lij vert^2 = (U^mag_i)^2 cdot vert I^s_lij vert^2 nonumber \nendalign","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Substitution:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign\n mboxVoltage from  (U^mag_i)^2 rightarrow w_i nonumber \n mboxVoltage to  (U^mag_j)^2 rightarrow w_j nonumber \n mboxSeries current  vert I^s_lij vert^2  rightarrow l^s_l nonumber \nendalign","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Note that l^s_l represents squared magnitude of the series current, i.e. the current flow through the series impedance in the pi-model. Power flow balance w.r.t. branch total losses","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign\n mboxActive power flow  P_lij + P_lji = g^sh_lij cdot w_i + r^s_l cdot l^s_l +  g^sh_lji cdot  w_j  nonumber \n mboxReactive power flow  Q_lij + Q_lji = -b^sh_lij cdot w_i + x^s_l cdot l^s_l  - b^sh_lji cdot  w_j nonumber \nendalign","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Power flow balance w.r.t. branch series losses:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign\n mboxActive power flow  P^s_lij + P^s_lji  = r^s_l cdot l^s_l  nonumber \n mboxReactive power flow  Q^s_lij + Q^s_lji  = x^s_l cdot l^s_l  nonumber \nendalign","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"Valid equality to link w_i l_lij P^s_lij Q^s_lij:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign\n mboxNonconvex current definition  (P^s_lij)^2 + (Q^s_lij)^2   =w_i cdot l_lij  nonumber \n mboxSOC current definition  (P^s_lij)^2 + (Q^s_lij)^2   leq w_i cdot l_lij  nonumber \nendalign","category":"page"},{"location":"developer/#Adding-an-ideal-transformer","page":"Developer","title":"Adding an ideal transformer","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"Adding an ideal transformer at the from side implicitly creates an internal branch voltage, between the transformer and the pi-section.","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign\n mboxNew voltage  w^_l nonumber \n mboxIdeal voltage magnitude transformer  w^_l = fracw_i(t^mag)^2 nonumber \nendalign","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"W.r.t to the pi-section only formulation, we effectively perform the following substitution in all the equations above:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign\n w_i rightarrow fracw_i(t^mag)^2 nonumber \nendalign","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"The branch's power balance isn't otherwise impacted by adding the ideal transformer, as such transformer is lossless.","category":"page"},{"location":"developer/#Adding-total-current-limits","page":"Developer","title":"Adding total current limits","text":"","category":"section"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign\n mboxTotal current from   vert I_lij vert leq I^rated_l nonumber \n mboxTotal current to   vert I_lji vert leq I^rated_l nonumber \nendalign","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"In squared voltage magnitude variables:","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"beginalign*\n mboxTotal current from   (P_lij)^2 + (Q_lij)^2  leq (I^rated_l)^2 cdot  w_i nonumber \n mboxTotal current to   (P_lji)^2 + (Q_lji)^2  leq (I^rated_l)^2 cdot w_j nonumber \nendalign*","category":"page"},{"location":"developer/","page":"Developer","title":"Developer","text":"[1]: Gan, L., Li, N., Topcu, U., & Low, S. (2012). Branch flow model for radial networks: convex relaxation. 51st IEEE Conference on Decision and Control, 1–8. Retrieved from http://smart.caltech.edu/papers/ExactRelaxation.pdf","category":"page"},{"location":"formulation-details/#Formulation-Details","page":"Formulation Details","title":"Formulation Details","text":"","category":"section"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"This section provides references to understand the formulations as provided by PowerModels. The list is not meant as a literature discussion, but to give the main starting points to understand the implementation of the formulations.","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"Molzahn, D., & Hiskens, I. (2019). A Survey of Relaxations and Approximations of the Power Flow Equations. Foundations and Trends in Electric Energy Systems https://doi.org/10.1561/3100000012\nCoffrin, C., & Roald, L. (2018). Convex relaxations in power system optimization: a brief introduction. [Math.OC], 1–5. Retrieved from http://arxiv.org/abs/1807.07227\nCoffrin, C., Hijazi, H., & Van Hentenryck, P. (2016). The QC relaxation: a theoretical and computational study on optimal power flow. IEEE Trans. Power Syst., 31(4), 3008–3018. https://doi.org/10.1109/TPWRS.2015.2463111","category":"page"},{"location":"formulation-details/#Notes-on-the-mathematical-model-for-all-formulations","page":"Formulation Details","title":"Notes on the mathematical model for all formulations","text":"","category":"section"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"PowerModels implements a slightly generalized version of the AC Optimal Power Flow problem from Matpower, as discussed in The PowerModels Mathematical Model and presented here.","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"In the next subsections the differences between PowerModels' bus and branch models and those commonly used in the literature are discussed. Consideration is given to these differences when implementing formulations from articles.","category":"page"},{"location":"formulation-details/#Standardized-branch-model","page":"Formulation Details","title":"Standardized branch model","text":"","category":"section"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"The branch model is standardized as follows:","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"An idealized (lossless) transformer at the from side of the branch (immediately on node i) with a fixed, complex-value voltage transformation (i.e. tap and shift)\nFollowed by a pi-section with complex-valued line shunt admittance, where the from and to side shunt can have different values\nA branch is uniquely defined by a tuple (lij) where l is the line index, i is the from node, and j is the to node.\nThermal limits are defined in apparent power, and are defined at both ends of a line\nEach branch has a phase angle difference constraint","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"Nevertheless, in the literature, the following can be observed:","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"The to and from side line shunts are equal\nThe line shunt admittance is a pure susceptance (equivalent to shunt conductance set to 0)\nA branch in a grid without parallel lines is uniquely defined by a tuple (ij) where i is the from node, and j is the to node.\nThermal limits are defined in current (total or series), complex power limits are approximated as a regular polygon, ...\nThermal limits are defined only at the from (or to) side\nPhase angle difference constraints are not included","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"Furthermore, \"lifted nonlinear cuts\" are used to improve the accuracy of PAD constraints for all formulations in the lifted S-W variable space:","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"Coffrin, C., Hijazi, H., & Van Hentenryck, P. (2017). Strengthening the SDP relaxation of ac power flows with convex envelopes, bound tightening, and valid inequalities. IEEE Trans. Power Syst., 32(5), 3549–3558. https://doi.org/10.1109/TPWRS.2016.2634586","category":"page"},{"location":"formulation-details/#Standardized-bus-model","page":"Formulation Details","title":"Standardized bus model","text":"","category":"section"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"The bus model is standardized as follows:","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"A bus defines a complex power balance for all the sets lines, generators, loads, bus shunts connected to it, i.e. one can define multiple load  and shunt  components on each bus i","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"Nevertheless, in the literature, a simplified bus model is often used:","category":"page"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"Only a single (aggregated) load per bus is supported\nOnly a single (aggregated) bus shunt per bus is supported","category":"page"},{"location":"formulation-details/#Exact-Non-Convex-Models","page":"Formulation Details","title":"Exact Non-Convex Models","text":"","category":"section"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"ACPPowerModel\nACRPowerModel\nACTPowerModel\nIVRPowerModel","category":"page"},{"location":"formulation-details/#PowerModels.ACPPowerModel","page":"Formulation Details","title":"PowerModels.ACPPowerModel","text":"AC power flow Model with polar bus voltage variables.\n\nThe seminal reference of AC OPF:\n\n@article{carpentier1962contribution,\n  title={Contribution to the economic dispatch problem},\n  author={Carpentier, J},\n  journal={Bulletin de la Societe Francoise des Electriciens},\n  volume={3},\n  number={8},\n  pages={431--447},\n  year={1962}\n}\n\nHistory and discussion:\n\n@techreport{Cain2012,\n  author = {Cain, Mary B and {O' Neill}, Richard P and Castillo, Anya},\n  title = {{History of optimal power flow and Models}},\n  pages = {1--36},\n  url = {https://www.ferc.gov/sites/default/files/2020-04/acopf-1-history-formulation-testing.pdf},\n  year = {2012}\n}\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.ACRPowerModel","page":"Formulation Details","title":"PowerModels.ACRPowerModel","text":"AC power flow Model with rectangular bus voltage variables.\n\n@techreport{Cain2012,\n  author = {Cain, Mary B and {O' Neill}, Richard P and Castillo, Anya},\n  title = {{History of optimal power flow and Models}},\n  pages = {1--36},\n  url = {https://www.ferc.gov/sites/default/files/2020-04/acopf-1-history-formulation-testing.pdf},\n  year = {2012}\n}\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.ACTPowerModel","page":"Formulation Details","title":"PowerModels.ACTPowerModel","text":"AC power flow Model (nonconvex) with variables for voltage angle, voltage magnitude squared, and real and imaginary part of voltage crossproducts. A tangens constraint is added to represent meshed networks in an exact manner.\n\n@ARTICLE{4349090,\n  author={R. A. Jabr},\n  title={A Conic Quadratic Format for the Load Flow Equations of Meshed Networks},\n  journal={IEEE Transactions on Power Systems},\n  year={2007},\n  month={Nov},\n  volume={22},\n  number={4},\n  pages={2285-2286},\n  doi={10.1109/TPWRS.2007.907590},\n  ISSN={0885-8950}\n}\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.IVRPowerModel","page":"Formulation Details","title":"PowerModels.IVRPowerModel","text":"Current voltage formulation of AC OPF. The formulation uses rectangular coordinates for both current and voltage.  Note that, even though Kirchhoff's circuit laws are linear in current and voltage, this formulation is nonconvex due to constants power loads/generators and apparent power limits.\n\n@techreport{ONeill2012,\n    author = {{O' Neill}, Richard P and Castillo, Anya and Cain, Mary B},\n    pages = {1--18},\n    title = {{The IV formulation and linear approximations of the ac optimal power flow problem}},\n    url = {https://www.ferc.gov/sites/default/files/2020-04/acopf-2-iv-linearization.pdf},\n    year = {2012}\n}\n\nApplicable to problem formulations with _iv in the name.\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#Linear-Approximations","page":"Formulation Details","title":"Linear Approximations","text":"","category":"section"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"DCPPowerModel\nDCMPPowerModel\nBFAPowerModel\nNFAPowerModel","category":"page"},{"location":"formulation-details/#PowerModels.DCPPowerModel","page":"Formulation Details","title":"PowerModels.DCPPowerModel","text":"Linearized 'DC' power flow Model with polar voltage variables.\n\nThis model is a basic linear active-power-only approximation, which uses branch susceptance values br_b = -br_x / (br_r^2 + br_x^2) for determining the network phase angles.  Furthermore, transformer parameters such as tap ratios and phase shifts are not considered as part of this model.\n\nIt is important to note that it is also common for active-power-only approximations to use 1/br_x for determining the network phase angles, instead of the br_b value that is used here.  Small discrepancies in solutions should be expected when comparing active-power-only approximations across multiple tools.\n\n@ARTICLE{4956966,\n  author={B. Stott and J. Jardim and O. Alsac},\n  journal={IEEE Transactions on Power Systems},\n  title={DC Power Flow Revisited},\n  year={2009},\n  month={Aug},\n  volume={24},\n  number={3},\n  pages={1290-1300},\n  doi={10.1109/TPWRS.2009.2021235},\n  ISSN={0885-8950}\n}\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.DCMPPowerModel","page":"Formulation Details","title":"PowerModels.DCMPPowerModel","text":"Linearized 'DC' power flow model with polar voltage variables.\n\nSimilar to the DCPPowerModel with the following changes:\n\nIt uses branch susceptance values br_b = -1 / br_x for determining the network phase angles.\nTransformer parameters such as tap ratios and phase shifts are considered.\n\nThe results should be equal to the results of matpower calculations.\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.BFAPowerModel","page":"Formulation Details","title":"PowerModels.BFAPowerModel","text":"Linear approximation of branch flow model.\n\nThe implementation builds on the second-order cone relaxation of the branch flow model, but neglects the active and reactive loss terms associated with the squared current magnitude so the power flow equations become linear. Note that flow bounds are still second order cones.\n\n@article{Baran1989OptimalSystems,\n    title = {{Optimal capacitor placement on radial distribution systems}},\n    year = {1989},\n    journal = {IEEE Transactions on Power Delivery},\n    author = {Baran, Mesut E. and Wu, Felix F.},\n    number = {1},\n    pages = {725--734},\n    volume = {4},\n    doi = {10.1109/61.19265},\n    issn = {19374208}\n}\n\nApplicable to problem formulations with _bf in the name.\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.NFAPowerModel","page":"Formulation Details","title":"PowerModels.NFAPowerModel","text":"The an active power only network flow approximation, also known as the transportation model.\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#Quadratic-Approximations","page":"Formulation Details","title":"Quadratic Approximations","text":"","category":"section"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"DCPLLPowerModel\nLPACCPowerModel","category":"page"},{"location":"formulation-details/#PowerModels.DCPLLPowerModel","page":"Formulation Details","title":"PowerModels.DCPLLPowerModel","text":"\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.LPACCPowerModel","page":"Formulation Details","title":"PowerModels.LPACCPowerModel","text":"The LPAC Cold-Start AC Power Flow Approximation.\n\nNote that the LPAC Cold-Start model requires the least amount of information but is also the least accurate variant of the LPAC Models.  If a nominal AC operating point is available, the LPAC Warm-Start model will provide improved accuracy.\n\nThe original publication suggests to use polyhedral outer approximations for the cosine and line thermal lit constraints.  Given the recent improvements in MIQCQP solvers, this implementation uses quadratic functions for those constraints.\n\n@article{doi:10.1287/ijoc.2014.0594,\n  author = {Coffrin, Carleton and Van Hentenryck, Pascal},\n  title = {A Linear-Programming Approximation of AC Power Flows},\n  journal = {INFORMS Journal on Computing},\n  volume = {26},\n  number = {4},\n  pages = {718-734},\n  year = {2014},\n  doi = {10.1287/ijoc.2014.0594},\n  eprint = {https://doi.org/10.1287/ijoc.2014.0594}\n}\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#Quadratic-Relaxations","page":"Formulation Details","title":"Quadratic Relaxations","text":"","category":"section"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"SOCWRPowerModel\nSOCWRConicPowerModel\nQCRMPowerModel\nQCLSPowerModel\nSOCBFPowerModel\nSOCBFConicPowerModel","category":"page"},{"location":"formulation-details/#PowerModels.SOCWRPowerModel","page":"Formulation Details","title":"PowerModels.SOCWRPowerModel","text":"Second-order cone relaxation of bus injection model of AC OPF.\n\nThe implementation casts this as a convex quadratically constrained problem.\n\n@article{1664986,\n  author={R. A. Jabr},\n  title={Radial distribution load flow using conic programming},\n  journal={IEEE Transactions on Power Systems},\n  year={2006},\n  month={Aug},\n  volume={21},\n  number={3},\n  pages={1458-1459},\n  doi={10.1109/TPWRS.2006.879234},\n  ISSN={0885-8950}\n}\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.SOCWRConicPowerModel","page":"Formulation Details","title":"PowerModels.SOCWRConicPowerModel","text":"Second-order cone relaxation of bus injection model of AC OPF.\n\nThis implementation casts the problem as a convex conic problem.\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.QCRMPowerModel","page":"Formulation Details","title":"PowerModels.QCRMPowerModel","text":"The \"Quadratic-Convex\" relaxation of the AC power flow equations. Recursive McCormik relaxations are used for the trilinear terms (i.e. QCRM).\n\n@Article{Hijazi2017,\n  author=\"Hijazi, Hassan and Coffrin, Carleton and Hentenryck, Pascal Van\",\n  title=\"Convex quadratic relaxations for mixed-integer nonlinear programs in power systems\",\n  journal=\"Mathematical Programming Computation\",\n  year=\"2017\",\n  month=\"Sep\",\n  volume=\"9\",\n  number=\"3\",\n  pages=\"321--367\",\n  issn=\"1867-2957\",\n  doi=\"10.1007/s12532-016-0112-z\",\n  url=\"https://doi.org/10.1007/s12532-016-0112-z\"\n}\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.QCLSPowerModel","page":"Formulation Details","title":"PowerModels.QCLSPowerModel","text":"A strengthened version of the \"Quadratic-Convex\" relaxation of the AC power flow equations. An extreme-point encoding of trilinar terms is used along with a constraint to link the lambda variables in multiple trilinar terms (i.e. QCLS).\n\n@misc{1809.04565,\n  author=\"Kaarthik Sundar and Harsha Nagarajan and Sidhant Misra and Mowen Lu and Carleton Coffrin and Russell Bent\",\n  title=\"Optimization-Based Bound Tightening using a Strengthened QC-Relaxation of the Optimal Power Flow Problem\",\n  year=\"2018\",\n  Eprint = \"arXiv:1809.04565\",\n}\n\nThe original model derivation is available in,\n\n@Article{Hijazi2017,\n  author=\"Hijazi, Hassan and Coffrin, Carleton and Hentenryck, Pascal Van\",\n  title=\"Convex quadratic relaxations for mixed-integer nonlinear programs in power systems\",\n  journal=\"Mathematical Programming Computation\",\n  year=\"2017\",\n  month=\"Sep\",\n  volume=\"9\",\n  number=\"3\",\n  pages=\"321--367\",\n  issn=\"1867-2957\",\n  doi=\"10.1007/s12532-016-0112-z\",\n  url=\"https://doi.org/10.1007/s12532-016-0112-z\"\n}\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.SOCBFPowerModel","page":"Formulation Details","title":"PowerModels.SOCBFPowerModel","text":"Second-order cone relaxation of branch flow model\n\nThe implementation casts this as a convex quadratically constrained problem.\n\n@INPROCEEDINGS{6425870,\n  author={M. Farivar and S. H. Low},\n  title={Branch flow model: Relaxations and convexification},\n  booktitle={2012 IEEE 51st IEEE Conference on Decision and Control (CDC)},\n  year={2012},\n  month={Dec},\n  pages={3672-3679},\n  doi={10.1109/CDC.2012.6425870},\n  ISSN={0191-2216}\n}\n\nExtended as discussed in:\n\n@misc{1506.04773,\n  author = {Carleton Coffrin and Hassan L. Hijazi and Pascal Van Hentenryck},\n  title = {DistFlow Extensions for AC Transmission Systems},\n  year = {2018},\n  eprint = {arXiv:1506.04773},\n  url = {https://arxiv.org/abs/1506.04773}\n}\n\nApplicable to problem formulations with _bf in the name.\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.SOCBFConicPowerModel","page":"Formulation Details","title":"PowerModels.SOCBFConicPowerModel","text":"\n\n\n\n","category":"type"},{"location":"formulation-details/#SDP-Relaxation","page":"Formulation Details","title":"SDP Relaxation","text":"","category":"section"},{"location":"formulation-details/","page":"Formulation Details","title":"Formulation Details","text":"SDPWRMPowerModel\nSparseSDPWRMPowerModel","category":"page"},{"location":"formulation-details/#PowerModels.SDPWRMPowerModel","page":"Formulation Details","title":"PowerModels.SDPWRMPowerModel","text":"Semi-definite relaxation of AC OPF\n\nOriginally proposed by:\n\n@article{BAI2008383,\n  author = \"Xiaoqing Bai and Hua Wei and Katsuki Fujisawa and Yong Wang\",\n  title = \"Semidefinite programming for optimal power flow problems\",\n  journal = \"International Journal of Electrical Power & Energy Systems\",\n  volume = \"30\",\n  number = \"6\",\n  pages = \"383 - 392\",\n  year = \"2008\",\n  issn = \"0142-0615\",\n  doi = \"https://doi.org/10.1016/j.ijepes.2007.12.003\",\n  url = \"http://www.sciencedirect.com/science/article/pii/S0142061507001378\",\n}\n\nFirst paper to use \"W\" variables in the BIM of AC OPF:\n\n@INPROCEEDINGS{6345272,\n  author={S. Sojoudi and J. Lavaei},\n  title={Physics of power networks makes hard optimization problems easy to solve},\n  booktitle={2012 IEEE Power and Energy Society General Meeting},\n  year={2012},\n  month={July},\n  pages={1-8},\n  doi={10.1109/PESGM.2012.6345272},\n  ISSN={1932-5517}\n}\n\n\n\n\n\n","category":"type"},{"location":"formulation-details/#PowerModels.SparseSDPWRMPowerModel","page":"Formulation Details","title":"PowerModels.SparseSDPWRMPowerModel","text":"Sparsity-exploiting semidefinite relaxation of AC OPF\n\nProposed in:\n\n@article{doi:10.1137/S1052623400366218,\n  author = {Fukuda, M. and Kojima, M. and Murota, K. and Nakata, K.},\n  title = {Exploiting Sparsity in Semidefinite Programming via Matrix Completion I: General Framework},\n  journal = {SIAM Journal on Optimization},\n  volume = {11},\n  number = {3},\n  pages = {647-674},\n  year = {2001},\n  doi = {10.1137/S1052623400366218},\n  URL = {https://doi.org/10.1137/S1052623400366218},\n  eprint = {https://doi.org/10.1137/S1052623400366218}\n}\n\nOriginal application to OPF by:\n\n@ARTICLE{6064917,\n  author={R. A. Jabr},\n  title={Exploiting Sparsity in SDP Relaxations of the OPF Problem},\n  journal={IEEE Transactions on Power Systems},\n  volume={27},\n  number={2},\n  pages={1138-1139},\n  year={2012},\n  month={May},\n  doi={10.1109/TPWRS.2011.2170772},\n  ISSN={0885-8950}\n}\n\n\n\n\n\n","category":"type"},{"location":"basic-data-utilities/#Basic-Data-Utilities","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"","category":"section"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"By default PowerModels uses a data model that captures the bulk of the features of realistic transmission network datasets such as, inactive devices, breakers and HVDC lines. However, these features preclude popular matrix-based analysis of power network datasets such as incidence, admittance, and power transfer distribution factor (PTDF) matrices. To support these types of analysis PowerModels introduces the concept of a basic networks, which are network datasets that satisfy the properties required to interpret the system in a matrix form.","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"The make_basic_network is provided to ensure that a given network dataset satisfies the properties required for a matrix interpretation (the specific requirements are outlined in the function documentation block). If the given dataset does not satisfy the properties, make_basic_network transforms the dataset to enforce them.","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"make_basic_network","category":"page"},{"location":"basic-data-utilities/#PowerModels.make_basic_network","page":"Basic Data Utilities","title":"PowerModels.make_basic_network","text":"given a powermodels data dict produces a new data dict that conforms to the following basic network model requirements.\n\nno dclines\nno switches\nno inactive components\nall components are numbered from 1-to-n\nthe network forms a single connected component\nthere exactly one phase angle reference bus\ngeneration cost functions are quadratic\nall branches have explicit thermal limits\nphase shift on all transformers is set to 0.0\nbus shunts have 0.0 conductance values\n\nusers requiring any of the features listed above for their analysis should use the non-basic PowerModels routines.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"The standard procedure for loading basic network data is as follows,","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"data = make_basic_network(parse_file(\"<path to network data file>\"))","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"modifications to the original network data file are indicated by logging messages in the terminal.","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"tip: Tip\nIf make_basic_network results in significant changes to a dataset, export_file can be used to inspect and modify the new derivative dataset that conforms to the basic network requirements.","category":"page"},{"location":"basic-data-utilities/#Matrix-Based-Data","page":"Basic Data Utilities","title":"Matrix-Based Data","text":"","category":"section"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"Using a basic network dataset the following functions can be used to extract key power system quantities in vectors and matrix forms. The prefix _basic_ distinguishes these functions from similar tools that operate on any type of PowerModels data, including those that are not amenable to a vector/matrix format.","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"calc_basic_bus_voltage\ncalc_basic_bus_injection\ncalc_basic_branch_series_impedance\ncalc_basic_incidence_matrix\ncalc_basic_admittance_matrix\ncalc_basic_susceptance_matrix\ncalc_basic_branch_susceptance_matrix\ncalc_basic_jacobian_matrix\ncalc_basic_ptdf_matrix\ncalc_basic_ptdf_row","category":"page"},{"location":"basic-data-utilities/#PowerModels.calc_basic_bus_voltage","page":"Basic Data Utilities","title":"PowerModels.calc_basic_bus_voltage","text":"given a basic network data dict, returns a complex valued vector of bus voltage values in rectangular coordinates as they appear in the network data.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/#PowerModels.calc_basic_bus_injection","page":"Basic Data Utilities","title":"PowerModels.calc_basic_bus_injection","text":"given a basic network data dict, returns a complex valued vector of bus power injections as they appear in the network data.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/#PowerModels.calc_basic_branch_series_impedance","page":"Basic Data Utilities","title":"PowerModels.calc_basic_branch_series_impedance","text":"given a basic network data dict, returns a complex valued vector of branch series impedances.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/#PowerModels.calc_basic_incidence_matrix","page":"Basic Data Utilities","title":"PowerModels.calc_basic_incidence_matrix","text":"given a basic network data dict, returns a sparse integer valued incidence matrix with one row for each branch and one column for each bus in the network. In each branch row a +1 is used to indicate the from bus and -1 is used to indicate to bus.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/#PowerModels.calc_basic_admittance_matrix","page":"Basic Data Utilities","title":"PowerModels.calc_basic_admittance_matrix","text":"given a basic network data dict, returns a sparse complex valued admittance matrix with one row and column for each bus in the network.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/#PowerModels.calc_basic_susceptance_matrix","page":"Basic Data Utilities","title":"PowerModels.calc_basic_susceptance_matrix","text":"given a basic network data dict, returns a sparse real valued susceptance matrix with one row and column for each bus in the network. This susceptance matrix reflects the imaginary part of an admittance matrix that only considers the branch series impedance.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/#PowerModels.calc_basic_branch_susceptance_matrix","page":"Basic Data Utilities","title":"PowerModels.calc_basic_branch_susceptance_matrix","text":"given a basic network data dict, returns a sparse real valued branch susceptance matrix with one row for each branch and one column for each bus in the network. Multiplying the branch susceptance matrix by bus phase angels yields a vector active power flow values for each branch.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/#PowerModels.calc_basic_jacobian_matrix","page":"Basic Data Utilities","title":"PowerModels.calc_basic_jacobian_matrix","text":"given a basic network data dict, returns a sparse real valued Jacobian matrix of the ac power flow problem.  The power variables are ordered by p and then q while voltage values are ordered by voltage angle and then voltage magnitude.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/#PowerModels.calc_basic_ptdf_matrix","page":"Basic Data Utilities","title":"PowerModels.calc_basic_ptdf_matrix","text":"given a basic network data dict, returns a real valued ptdf matrix with one row for each branch and one column for each bus in the network. Multiplying the ptdf matrix by bus injection values yields a vector active power flow values on each branch.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/#PowerModels.calc_basic_ptdf_row","page":"Basic Data Utilities","title":"PowerModels.calc_basic_ptdf_row","text":"given a basic network data dict and a branch index returns a row of the ptdf matrix reflecting that branch.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"warning: Warning\nSeveral variants of the real-valued susceptance matrix are possible. PowerModels uses the version based on inverse of branch series impedance, that is imag(inv(r + x im)). One may observe slightly different results when compared to tools that use other variants such as 1/x.","category":"page"},{"location":"basic-data-utilities/#Matrix-Based-Computations","page":"Basic Data Utilities","title":"Matrix-Based Computations","text":"","category":"section"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"Matrix-based network data can be combined to compute a number of useful quantities. For example, by combining the incidence matrix and the series impedance one can drive the susceptance and branch susceptance matrices as follows,","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"import LinearAlgebra: Diagonal\n\nbz = calc_basic_branch_series_impedance(data)\nA  = calc_basic_incidence_matrix(data)\n\nY  = imag(Diagonal(inv.(bz)))\nB  = A'*Y*A    # equivalent to calc_basic_susceptance_matrix\nBB = (A'*Y)'   # equivalent to calc_basic_branch_susceptance_matrix","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"The bus voltage angles can be combined with the susceptance and branch susceptance matrices to observe how power flows through the network as follows,","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"va = angle.(calc_basic_bus_voltage(data))\nB  = calc_basic_susceptance_matrix(data)\nBB = calc_basic_branch_susceptance_matrix(data)\n\nbus_injection =  -B * va\nbranch_power  = -BB * va","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"In the inverse operation, bus injection values can be combined with a PTDF matrix to compute branch flow values as follows,","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"bi   = real(calc_basic_bus_injection(data))\nPTDF = calc_basic_ptdf_matrix(data)\n\nbranch_power = PTDF * bi","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"Finally, the following function provides a tool to solve a DC power flow on basic network data using Julia's native linear equation solver,","category":"page"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"compute_basic_dc_pf","category":"page"},{"location":"basic-data-utilities/#PowerModels.compute_basic_dc_pf","page":"Basic Data Utilities","title":"PowerModels.compute_basic_dc_pf","text":"given a basic network data dict, computes real valued vector of bus voltage phase angles by solving a dc power flow.\n\n\n\n\n\n","category":"function"},{"location":"basic-data-utilities/","page":"Basic Data Utilities","title":"Basic Data Utilities","text":"tip: Tip\nBy default PowerModels uses Julia's SparseArrays to ensure the best performance of matrix operations on large power network datasets. The function Matrix(sparse_array) can be used to covert a sparse matrix into a full matrix when that is preferred.","category":"page"},{"location":"parser/#File-IO","page":"File IO","title":"File IO","text":"","category":"section"},{"location":"parser/","page":"File IO","title":"File IO","text":"CurrentModule = PowerModels","category":"page"},{"location":"parser/#General-Data-Formats","page":"File IO","title":"General Data Formats","text":"","category":"section"},{"location":"parser/","page":"File IO","title":"File IO","text":"parse_file\nparse_json","category":"page"},{"location":"parser/#PowerModels.parse_file","page":"File IO","title":"PowerModels.parse_file","text":"parse_file(io::String; import_all=false, validate=true)\nparse_file(io::IO; import_all=false, validate=true, filetype=\"json\")\n\nParse a file into a PowerModels data structure.\n\nThe supported file types are:\n\n.m: a Matpower file\n.raw: a PTI (PSS(R)E-v33)\n.json: a PowerModels.jl JSON file\n\nAll fields from PTI files will be imported if import_all is true.\n\nIf validate = true, PowerModels will validate the imported data for correctness.\n\n\n\n\n\n","category":"function"},{"location":"parser/#PowerModels.parse_json","page":"File IO","title":"PowerModels.parse_json","text":"Parses json from iostream or string\n\n\n\n\n\n","category":"function"},{"location":"parser/#Matpower-Data-Files","page":"File IO","title":"Matpower Data Files","text":"","category":"section"},{"location":"parser/","page":"File IO","title":"File IO","text":"The following method is the main exported methods for parsing Matpower data files:","category":"page"},{"location":"parser/","page":"File IO","title":"File IO","text":"parse_matpower","category":"page"},{"location":"parser/#PowerModels.parse_matpower","page":"File IO","title":"PowerModels.parse_matpower","text":"Parses the matpwer data from either a filename or an IO object\n\n\n\n\n\n","category":"function"},{"location":"parser/","page":"File IO","title":"File IO","text":"We also provide the following (internal) helper methods:","category":"page"},{"location":"parser/","page":"File IO","title":"File IO","text":"Modules = [PowerModels]\nPages   = [\"io/matpower.jl\"]\nOrder   = [:function]\nPrivate  = true","category":"page"},{"location":"parser/#PowerModels._add_dcline_costs!-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._add_dcline_costs!","text":"adds dcline costs, if gen costs exist\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._export_cost_data-Tuple{IO, Dict{Int64, Dict}, String}","page":"File IO","title":"PowerModels._export_cost_data","text":"Export cost data\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._export_extra_data","page":"File IO","title":"PowerModels._export_extra_data","text":"Export fields of a component type\n\n\n\n\n\n","category":"function"},{"location":"parser/#PowerModels._get_default","page":"File IO","title":"PowerModels._get_default","text":"Get a default value for dict entry \n\n\n\n\n\n","category":"function"},{"location":"parser/#PowerModels._matpower_to_powermodels!-Tuple{Dict{String}}","page":"File IO","title":"PowerModels._matpower_to_powermodels!","text":"Converts a Matpower dict into a PowerModels dict\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._merge_bus_name_data!-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._merge_bus_name_data!","text":"merges bus name data into buses, if names exist\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._merge_cost_data!-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._merge_cost_data!","text":"merges generator cost functions into generator data, if costs exist\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._merge_generic_data!-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._merge_generic_data!","text":"merges Matpower tables based on the table extension syntax\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._mp2pm_branch!-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._mp2pm_branch!","text":"sets all branch transformer taps to 1.0, to simplify branch models\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._mp2pm_dcline!-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._mp2pm_dcline!","text":"adds pmin and pmax values at to and from buses\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._split_loads_shunts!-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._split_loads_shunts!","text":"_split_loads_shunts!(data)\n\nSeperates Loads and Shunts in data under separate \"load\" and \"shunt\" keys in the PowerModels data format. Includes references to originating bus via \"loadbus\" and \"shuntbus\" keys, respectively.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.export_matpower-Tuple{AbstractString, Dict{String, Any}}","page":"File IO","title":"PowerModels.export_matpower","text":"Export power network data to a file in the matpower format\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.export_matpower-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels.export_matpower","text":"Export power network data in the matpower format\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.export_matpower-Tuple{IO, Dict{String, Any}}","page":"File IO","title":"PowerModels.export_matpower","text":"Export power network data in the matpower format\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.parse_matpower-Tuple{IO}","page":"File IO","title":"PowerModels.parse_matpower","text":"Parses the matpwer data from either a filename or an IO object\n\n\n\n\n\n","category":"method"},{"location":"parser/#PTI-Data-Files-(PSS/E)","page":"File IO","title":"PTI Data Files (PSS/E)","text":"","category":"section"},{"location":"parser/","page":"File IO","title":"File IO","text":"Note: This feature supports the parsing and conversion of PTI files into a PowerModels format for the following power network components: buses, loads, shunts (fixed and approximation of switched), branches, two-winding and three-winding transformers (incl. magnetizing admittance), generators, two-terminal dc lines, and voltage source converter HVDC lines.","category":"page"},{"location":"parser/","page":"File IO","title":"File IO","text":"The following method is the main exported method for parsing PSS(R)E v33 specified PTI data files:","category":"page"},{"location":"parser/","page":"File IO","title":"File IO","text":"parse_pti\nparse_psse","category":"page"},{"location":"parser/#PowerModels.parse_pti","page":"File IO","title":"PowerModels.parse_pti","text":"parse_pti(filename::String)\n\nOpen PTI raw file given by filename, returning a Dict of the data parsed into the proper types.\n\n\n\n\n\nparse_pti(io::IO)\n\nReads PTI data in io::IO, returning a Dict of the data parsed into the proper types.\n\n\n\n\n\n","category":"function"},{"location":"parser/#PowerModels.parse_psse","page":"File IO","title":"PowerModels.parse_psse","text":"parse_psse(filename::String; kwargs...)::Dict\n\nParses directly from file\n\n\n\n\n\nfunction parse_psse(io::IO; kwargs...)::Dict\n\nParses directly from iostream\n\n\n\n\n\n","category":"function"},{"location":"parser/","page":"File IO","title":"File IO","text":"The following internal helper methods are also provided:","category":"page"},{"location":"parser/","page":"File IO","title":"File IO","text":"Modules = [PowerModels]\nPages   = [\"io/psse.jl\"]\nOrder   = [:function]\nPrivate  = true","category":"page"},{"location":"parser/#PowerModels._create_starbus_from_transformer-Tuple{Dict, Dict, Int64}","page":"File IO","title":"PowerModels._create_starbus_from_transformer","text":"create_starbus(pm_data, transformer)\n\nCreates a starbus from a given three-winding transformer. \"sourceid\" is given by `[\"busi\", \"name\", \"I\", \"J\", \"K\", \"CKT\"]` where \"bus_i\" and \"name\" are the modified names for the starbus, and \"I\", \"J\", \"K\" and \"CKT\" come from the originating transformer, in the PSS(R)E transformer specification.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._find_max_bus_id-Tuple{Dict}","page":"File IO","title":"PowerModels._find_max_bus_id","text":"_find_max_bus_id(pm_data)\n\nReturns the maximum bus id in pm_data\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._get_bus_value-Tuple{Any, Any, Any}","page":"File IO","title":"PowerModels._get_bus_value","text":"_get_bus_value(bus_i, field, pm_data)\n\nReturns the value of field of bus_i from the PowerModels data. Requires \"bus\" Dict to already be populated.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._import_remaining_comps!-Tuple{Dict, Dict}","page":"File IO","title":"PowerModels._import_remaining_comps!","text":"Imports remaining top level component lists from data_in into data_out, excluding keys in exclude\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._import_remaining_keys!-Tuple{Dict, Dict}","page":"File IO","title":"PowerModels._import_remaining_keys!","text":"Imports remaining keys from a source component into detestation component, excluding keys in exclude\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._init_bus!-Tuple{Dict{String, Any}, Int64}","page":"File IO","title":"PowerModels._init_bus!","text":"_init_bus!(bus, id)\n\nInitializes a bus of id id with default values given in the PSS(R)E specification.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._psse2pm_branch!-Tuple{Dict, Dict, Bool}","page":"File IO","title":"PowerModels._psse2pm_branch!","text":"_psse2pm_branch!(pm_data, pti_data)\n\nParses PSS(R)E-style Branch data into a PowerModels-style Dict. \"source_id\" is given by [\"I\", \"J\", \"CKT\"] in PSS(R)E Branch specification.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._psse2pm_bus!-Tuple{Dict, Dict, Bool}","page":"File IO","title":"PowerModels._psse2pm_bus!","text":"_psse2pm_bus!(pm_data, pti_data)\n\nParses PSS(R)E-style Bus data into a PowerModels-style Dict. \"source_id\" is given by [\"I\", \"NAME\"] in PSS(R)E Bus specification.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._psse2pm_dcline!-Tuple{Dict, Dict, Bool}","page":"File IO","title":"PowerModels._psse2pm_dcline!","text":"_psse2pm_dcline!(pm_data, pti_data)\n\nParses PSS(R)E-style Two-Terminal and VSC DC Lines data into a PowerModels compatible Dict structure by first converting them to a simple DC Line Model. For Two-Terminal DC lines, \"sourceid\" is given by [\"IPR\", \"IPI\", \"NAME\"] in the PSS(R)E Two-Terminal DC specification. For Voltage Source Converters, \"sourceid\" is given by [\"IBUS1\", \"IBUS2\", \"NAME\"], where \"IBUS1\" is \"IBUS\" of the first converter bus, and \"IBUS2\" is the \"IBUS\" of the second converter bus, in the PSS(R)E Voltage Source Converter specification.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._psse2pm_generator!-Tuple{Dict, Dict, Bool}","page":"File IO","title":"PowerModels._psse2pm_generator!","text":"_psse2pm_generator!(pm_data, pti_data)\n\nParses PSS(R)E-style Generator data in a PowerModels-style Dict. \"source_id\" is given by [\"I\", \"ID\"] in PSS(R)E Generator specification.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._psse2pm_load!-Tuple{Dict, Dict, Bool}","page":"File IO","title":"PowerModels._psse2pm_load!","text":"_psse2pm_load!(pm_data, pti_data)\n\nParses PSS(R)E-style Load data into a PowerModels-style Dict. \"source_id\" is given by [\"I\", \"ID\"] in the PSS(R)E Load specification.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._psse2pm_shunt!-Tuple{Dict, Dict, Bool}","page":"File IO","title":"PowerModels._psse2pm_shunt!","text":"_psse2pm_shunt!(pm_data, pti_data)\n\nParses PSS(R)E-style Fixed and Switched Shunt data into a PowerModels-style Dict. \"source_id\" is given by [\"I\", \"ID\"] for Fixed Shunts, and [\"I\", \"SWREM\"] for Switched Shunts, as given by the PSS(R)E Fixed and Switched Shunts specifications.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._psse2pm_transformer!-Tuple{Dict, Dict, Bool}","page":"File IO","title":"PowerModels._psse2pm_transformer!","text":"_psse2pm_transformer!(pm_data, pti_data)\n\nParses PSS(R)E-style Transformer data into a PowerModels-style Dict. \"source_id\" is given by [\"I\", \"J\", \"K\", \"CKT\", \"winding\"], where \"winding\" is 0 if transformer is two-winding, and 1, 2, or 3 for three-winding, and the remaining keys are defined in the PSS(R)E Transformer specification.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pti_to_powermodels!-Tuple{Dict}","page":"File IO","title":"PowerModels._pti_to_powermodels!","text":"_pti_to_powermodels!(pti_data)\n\nConverts PSS(R)E-style data parsed from a PTI raw file, passed by pti_data into a format suitable for use internally in PowerModels. Imports all remaining data from the PTI file if import_all is true (Default: false).\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.parse_psse-Tuple{IO}","page":"File IO","title":"PowerModels.parse_psse","text":"function parse_psse(io::IO; kwargs...)::Dict\n\nParses directly from iostream\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.parse_psse-Tuple{String}","page":"File IO","title":"PowerModels.parse_psse","text":"parse_psse(filename::String; kwargs...)::Dict\n\nParses directly from file\n\n\n\n\n\n","category":"method"},{"location":"parser/","page":"File IO","title":"File IO","text":"Modules = [PowerModels]\nPages   = [\"io/pti.jl\"]\nOrder   = [:function]\nPrivate  = true","category":"page"},{"location":"parser/#PowerModels._export_remaining!-Tuple{Dict{String, Any}, Dict{String, Any}, Dict{String, Any}}","page":"File IO","title":"PowerModels._export_remaining!","text":"Export remaining keys of a componet\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._get_line_elements-Tuple{AbstractString}","page":"File IO","title":"PowerModels._get_line_elements","text":"_get_line_elements(line)\n\nInternal function. Uses regular expressions to extract all separate data elements from a line of a PTI file and populate them into an Array{String}. Comments, typically indicated at the end of a line with a '/' character, are also extracted separately, and Array{Array{String}, String} is returned.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._parse_elements-Tuple{Array, Array, Dict, AbstractString}","page":"File IO","title":"PowerModels._parse_elements","text":"This is an experimental method for parsing elements and setting defaults at the same time. It is not currently working but would reduce memory allocations if implemented correctly.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._parse_line_element!-Tuple{Dict, Array, AbstractString}","page":"File IO","title":"PowerModels._parse_line_element!","text":"_parse_line_element!(data, elements, section)\n\nInternal function. Parses a single \"line\" of data elements from a PTI file, as given by elements which is an array of the line, typically split at ,. Elements are parsed into data types given by section and saved into data::Dict.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._parse_pti_data-Tuple{IO}","page":"File IO","title":"PowerModels._parse_pti_data","text":"_parse_pti_data(data_string, sections)\n\nInternal function. Parse a PTI raw file into a Dict, given the data_string of the file and a list of the sections in the PTI file (typically given by default by get_pti_sections().\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_2w_tran","page":"File IO","title":"PowerModels._pm2psse_2w_tran","text":"Parses PM transformer branch to PSS(R) E-style. returns a dict with all the keys later pass this dict to printptistr with differents _transformerdtypes\n\nReference: PSSE 33 - POM - 5-20\n\n\n\n\n\n","category":"function"},{"location":"parser/#PowerModels._pm2psse_3w_tran-Tuple{Dict{String, Any}, Int64, Float64}","page":"File IO","title":"PowerModels._pm2psse_3w_tran","text":"Parses 3 PM transformer branch to PSS(R) E-style.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_area_interchange-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._pm2psse_area_interchange","text":"Parses PM area interchange to PSS(R) E-style\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_branch-Tuple{Dict{String, Any}, Int64}","page":"File IO","title":"PowerModels._pm2psse_branch","text":"Parses PM branch data to PSS(R) E-style.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_bus-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._pm2psse_bus","text":"Parses PM Bus data to PSS(R)E-style.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_fixed_shunt-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._pm2psse_fixed_shunt","text":"Parses PM fixed shunt to PSS(R)E-style\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_generator-Tuple{Dict{String, Any}, Int64, Int64, Int64}","page":"File IO","title":"PowerModels._pm2psse_generator","text":"Parses PM generator data to PSS(R)E-style.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_header-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._pm2psse_header","text":"Create a header for the case\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_interarea-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._pm2psse_interarea","text":"Parses PM interarea to PSS(R) E-style\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_load-Tuple{Dict{String, Any}, Int64, Int64, Int64}","page":"File IO","title":"PowerModels._pm2psse_load","text":"Parses PM Load data to PSS(R)E-style.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_owner-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._pm2psse_owner","text":"Parses PM zone to PSS(R) E-style\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_switched_shunt-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._pm2psse_switched_shunt","text":"Parses PM fixed shunt to PSS(R)E-style\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_tt_dc_line-Tuple{Dict{String, Any}, Dict{String, Any}, Dict{String, Any}}","page":"File IO","title":"PowerModels._pm2psse_tt_dc_line","text":"Parses PM dcline to PSS(R)E style\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._pm2psse_zone-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels._pm2psse_zone","text":"Parses PM zone to PSS(R) E-style\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._populate_defaults!-Tuple{Dict}","page":"File IO","title":"PowerModels._populate_defaults!","text":"_populate_defaults!(pti_data)\n\nInternal function. Populates empty fields with PSS(R)E PTI v33 default values\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels._print_pti_str-Tuple{IO, Any, Any}","page":"File IO","title":"PowerModels._print_pti_str","text":"Given a PTI component dict print it in the .raw file\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.export_pti-Tuple{AbstractString, Dict{String, Any}}","page":"File IO","title":"PowerModels.export_pti","text":"Export power network data to a file in the pti format\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.export_pti-Tuple{Dict{String, Any}}","page":"File IO","title":"PowerModels.export_pti","text":"Export power network data in the pti format\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.export_pti-Tuple{IO, Dict{String, Any}}","page":"File IO","title":"PowerModels.export_pti","text":"export_pti(io::IO, data::Dict{String, Any})\n\nExport PowerModels network data dictionary to the as a power flow raw data acording to the pti format RAW V33. \n\nIt is highly recommend to export the PowerModel data dictionary in the same format as the source data. \n\nThe export_pti function exports the essential components of a network:\n\nBuses\nLoads\nFixed Shunts\nGenerators\nNon Tansformers Branchs\nTransformers (Two-Windings and Three-Windings)\nSwitched Shunts (aproximate)\n\nIf the PowerModels was parsed from a pti file with the import_all=true parameter: data = parse_file(case3.raw, import_all=true) \n\nIt will export these aditionals items:\n\nHeader Options\nComment Lines\nZone Data\nArea Data\nOwner Data\nSwitched Shunts (with block steps)\n\nThings that are not exported:\n\nTNEP network specification\nGeneration Cost Data\nStorage\nSwitches\nDC Lines (future work, #754)\n\nThings that are not exported if you use import_all = true to make the PowerModel data dict:\n\nFACTS (Maybe in future work)\nGNE (No intentions to export it)\nInter Area Transfer Data (No intentions to export it)\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.parse_pti-Tuple{IO}","page":"File IO","title":"PowerModels.parse_pti","text":"parse_pti(io::IO)\n\nReads PTI data in io::IO, returning a Dict of the data parsed into the proper types.\n\n\n\n\n\n","category":"method"},{"location":"parser/#PowerModels.parse_pti-Tuple{String}","page":"File IO","title":"PowerModels.parse_pti","text":"parse_pti(filename::String)\n\nOpen PTI raw file given by filename, returning a Dict of the data parsed into the proper types.\n\n\n\n\n\n","category":"method"},{"location":"quickguide/#Quick-Start-Guide","page":"Getting Started","title":"Quick Start Guide","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Once PowerModels is installed, Ipopt is installed, and a network data file (e.g. \"case3.m\" or \"case3.raw\") has been acquired, an AC Optimal Power Flow can be executed with,","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"using PowerModels\nusing Ipopt\n\nsolve_ac_opf(\"matpower/case3.m\", Ipopt.Optimizer)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Similarly, a DC Optimal Power Flow can be executed with","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"solve_dc_opf(\"matpower/case3.m\", Ipopt.Optimizer)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"PTI .raw files in the PSS(R)E v33 specification can be run similarly, e.g. in the case of an AC Optimal Power Flow","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"solve_ac_opf(\"case3.raw\", Ipopt.Optimizer)","category":"page"},{"location":"quickguide/#Getting-Results","page":"Getting Started","title":"Getting Results","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"The run commands in PowerModels return detailed results data in the form of a dictionary. Results dictionaries from either Matpower .m or PTI .raw files will be identical in format. This dictionary can be saved for further processing as follows,","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"result = solve_ac_opf(\"matpower/case3.m\", Ipopt.Optimizer)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"For example, the algorithm's runtime and final objective value can be accessed with,","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"result[\"solve_time\"]\nresult[\"objective\"]","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"The \"solution\" field contains detailed information about the solution produced by the run method. For example, the following dictionary comprehension can be used to inspect the bus voltage angles in the solution,","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Dict(name => data[\"va\"] for (name, data) in result[\"solution\"][\"bus\"])","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"The print_summary(result[\"solution\"]) function can be used show an table-like overview of the solution data.  For more information about PowerModels result data see the PowerModels Result Data Format section.","category":"page"},{"location":"quickguide/#Accessing-Different-Formulations","page":"Getting Started","title":"Accessing Different Formulations","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"The function solve_ac_opf and solve_dc_opf are shorthands for a more general formulation-independent OPF execution, solve_opf. For example, solve_ac_opf is equivalent to,","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"solve_opf(\"matpower/case3.m\", ACPPowerModel, Ipopt.Optimizer)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"where \"ACPPowerModel\" indicates an AC formulation in polar coordinates.  This more generic solve_opf() allows one to solve an OPF problem with any power network formulation implemented in PowerModels.  For example, an SOC Optimal Power Flow can be run with,","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"solve_opf(\"matpower/case3.m\", SOCWRPowerModel, Ipopt.Optimizer)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Formulation Details provides a list of available formulations.","category":"page"},{"location":"quickguide/#Modifying-Network-Data","page":"Getting Started","title":"Modifying Network Data","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates one way to perform multiple PowerModels solves while modifing the network data in Julia,","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"network_data = PowerModels.parse_file(\"matpower/case3.m\")\n\nsolve_opf(network_data, ACPPowerModel, Ipopt.Optimizer)\n\nnetwork_data[\"load\"][\"3\"][\"pd\"] = 0.0\nnetwork_data[\"load\"][\"3\"][\"qd\"] = 0.0\n\nsolve_opf(network_data, ACPPowerModel, Ipopt.Optimizer)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Network data parsed from PTI .raw files supports data extensions, i.e. data fields that are within the PSS(R)E specification, but not used by PowerModels for calculation. This can be achieved by","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"network_data = PowerModels.parse_file(\"pti/case3.raw\"; import_all=true)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"This network data can be modified in the same way as the previous Matpower .m file example. For additional details about the network data, see the PowerModels Network Data Format section.","category":"page"},{"location":"quickguide/#Inspecting-AC-and-DC-branch-flow-results","page":"Getting Started","title":"Inspecting AC and DC branch flow results","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"The flow AC and DC branch results are written to the result by default. The following can be used to inspect the flow results:","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"result = solve_opf(\"matpower/case3_dc.m\", ACPPowerModel, Ipopt.Optimizer)\nresult[\"solution\"][\"dcline\"][\"1\"]\nresult[\"solution\"][\"branch\"][\"2\"]","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"The losses of an AC or DC branch can be derived:","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"loss_ac =  Dict(name => data[\"pt\"]+data[\"pf\"] for (name, data) in result[\"solution\"][\"branch\"])\nloss_dc =  Dict(name => data[\"pt\"]+data[\"pf\"] for (name, data) in result[\"solution\"][\"dcline\"])","category":"page"},{"location":"quickguide/#Building-PowerModels-from-Network-Data-Dictionaries","page":"Getting Started","title":"Building PowerModels from Network Data Dictionaries","text":"","category":"section"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"The following example demonstrates how to break a solve_opf call into separate model building and solving steps.  This allows inspection of the JuMP model created by PowerModels for the AC-OPF problem,","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"pm = instantiate_model(\"matpower/case3.m\", ACPPowerModel, PowerModels.build_opf)\n\nprint(pm.model)\n\nresult = optimize_model!(pm, optimizer=Ipopt.Optimizer)","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"Alternatively, you can further break it up by parsing a file into a network data dictionary, before passing it on to instantiate_model() like so,","category":"page"},{"location":"quickguide/","page":"Getting Started","title":"Getting Started","text":"network_data = PowerModels.parse_file(\"matpower/case3.m\")\n\npm = instantiate_model(network_data, ACPPowerModel, PowerModels.build_opf)\n\nprint(pm.model)\n\nresult = optimize_model!(pm, optimizer=Ipopt.Optimizer)","category":"page"},{"location":"constraints/#Constraints","page":"Constraints","title":"Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"CurrentModule = PowerModels","category":"page"},{"location":"constraints/#Constraint-Templates","page":"Constraints","title":"Constraint Templates","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"Constraint templates help simplify data wrangling across multiple Power Flow formulations by providing an abstraction layer between the network data and network constraint definitions. The constraint template's job is to extract the required parameters from a given network data structure and pass the data as named arguments to the Power Flow formulations.","category":"page"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"These templates should be defined over AbstractPowerModel and should not refer to model variables. For more details, see the files: core/constraint_template.jl and core/constraint.jl (core/constraint_template.jl provides higher level APIs, and pulls out index information from the data dictionaries, before calling out to methods defined in core/constraint.jl).","category":"page"},{"location":"constraints/#Voltage-Constraints","page":"Constraints","title":"Voltage Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_model_voltage\nconstraint_model_voltage_on_off\nconstraint_ne_model_voltage","category":"page"},{"location":"constraints/#PowerModels.constraint_model_voltage","page":"Constraints","title":"PowerModels.constraint_model_voltage","text":"This constraint captures problem agnostic constraints that are used to link the model's voltage variables together, in addition to the standard problem formulation constraints.\n\nNotable examples include the constraints linking the voltages in the ACTPowerModel, constraints linking convex relaxations of voltage variables.\n\n\n\n\n\ndo nothing, most models to not require any model-specific voltage constraints\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_model_voltage_on_off","page":"Constraints","title":"PowerModels.constraint_model_voltage_on_off","text":"This constraint captures problem agnostic constraints that are used to link the model's voltage variables together, in addition to the standard problem formulation constraints.  The on/off name indicates that the voltages in this constraint can be set to zero via an indicator variable\n\nNotable examples include the constraints linking the voltages in the ACTPowerModel, constraints linking convex relaxations of voltage variables.\n\n\n\n\n\ndo nothing, most models to not require any model-specific on/off voltage constraints\n\n\n\n\n\ndo nothing, this model does not have complex voltage constraints\n\n\n\n\n\ndo nothing, this model does not have complex voltage variables\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ne_model_voltage","page":"Constraints","title":"PowerModels.constraint_ne_model_voltage","text":"This constraint captures problem agnostic constraints that are used to link the model's voltage variables together, in addition to the standard problem formulation constraints.  The network expantion name (ne) indicates that the voltages in this constraint can be set to zero via an indicator variable\n\nNotable examples include the constraints linking the voltages in the ACTPowerModel, constraints linking convex relaxations of voltage variables.\n\n\n\n\n\ndo nothing, most models to not require any model-specific network expansion voltage constraints\n\n\n\n\n\ndo nothing, this model does not have complex voltage constraints\n\n\n\n\n\ndo nothing, this model does not have complex voltage variables\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Generator-Constraints","page":"Constraints","title":"Generator Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_gen_setpoint_active\nconstraint_gen_setpoint_reactive","category":"page"},{"location":"constraints/#PowerModels.constraint_gen_setpoint_active","page":"Constraints","title":"PowerModels.constraint_gen_setpoint_active","text":"pg[i] == pg\n\n\n\n\n\npg[i] == pg\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_gen_setpoint_reactive","page":"Constraints","title":"PowerModels.constraint_gen_setpoint_reactive","text":"qq[i] == qq\n\n\n\n\n\nqq[i] == qq\n\n\n\n\n\ndo nothing, apo models do not have reactive variables\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Bus-Constraints","page":"Constraints","title":"Bus Constraints","text":"","category":"section"},{"location":"constraints/#Setpoint-Constraints","page":"Constraints","title":"Setpoint Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_theta_ref\nconstraint_voltage_magnitude_setpoint","category":"page"},{"location":"constraints/#PowerModels.constraint_theta_ref","page":"Constraints","title":"PowerModels.constraint_theta_ref","text":"reference bus angle constraint\n\n\n\n\n\nt[ref_bus] == 0\n\n\n\n\n\nnothing to do, no voltage angle variables\n\n\n\n\n\nt[ref_bus] == 0\n\n\n\n\n\nDo nothing, no way to represent this in these variables\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_voltage_magnitude_setpoint","page":"Constraints","title":"PowerModels.constraint_voltage_magnitude_setpoint","text":"v[i] == vm\n\n\n\n\n\nv[i] == vm\n\n\n\n\n\ndo nothing, this model does not have voltage variables\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Power-Balance-Constraints","page":"Constraints","title":"Power Balance Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_power_balance\nconstraint_power_balance_ls\nconstraint_ne_power_balance","category":"page"},{"location":"constraints/#PowerModels.constraint_power_balance_ls","page":"Constraints","title":"PowerModels.constraint_power_balance_ls","text":"nodal power balance with constant power factor load and shunt shedding\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Branch-Constraints","page":"Constraints","title":"Branch Constraints","text":"","category":"section"},{"location":"constraints/#Ohm's-Law-Constraints","page":"Constraints","title":"Ohm's Law Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_ohms_yt_from\nconstraint_ohms_yt_to\nconstraint_ohms_y_from\nconstraint_ohms_y_to","category":"page"},{"location":"constraints/#PowerModels.constraint_ohms_yt_from","page":"Constraints","title":"PowerModels.constraint_ohms_yt_from","text":"Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\np[f_idx] ==  (g+g_fr)/tm*v[f_bus]^2 + (-g*tr+b*ti)/tm^2*(v[f_bus]*v[t_bus]*cos(t[f_bus]-t[t_bus])) + (-b*tr-g*ti)/tm^2*(v[f_bus]*v[t_bus]*sin(t[f_bus]-t[t_bus]))\nq[f_idx] == -(b+b_fr)/tm*v[f_bus]^2 - (-b*tr-g*ti)/tm^2*(v[f_bus]*v[t_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr+b*ti)/tm^2*(v[f_bus]*v[t_bus]*sin(t[f_bus]-t[t_bus]))\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\np[f_idx] == -b*(t[f_bus] - t[t_bus])\n\n\n\n\n\nnothing to do, no voltage angle variables\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ohms_yt_to","page":"Constraints","title":"PowerModels.constraint_ohms_yt_to","text":"Creates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\np[t_idx] ==  (g+g_to)*v[t_bus]^2 + (-g*tr-b*ti)/tm^2*(v[t_bus]*v[f_bus]*cos(t[t_bus]-t[f_bus])) + (-b*tr+g*ti)/tm^2*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))\nq[t_idx] == -(b+b_to)*v[t_bus]^2 - (-b*tr+g*ti)/tm^2*(v[t_bus]*v[f_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr-b*ti)/tm^2*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus]))\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\n\n\n\n\nnothing to do, this model is symetric\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ohms_y_from","page":"Constraints","title":"PowerModels.constraint_ohms_y_from","text":"Creates Ohms constraints for AC models (y post fix indicates that Y values are in rectangular form)\n\np[f_idx] ==  (g+g_fr)*(v[f_bus]/tr)^2 + -g*v[f_bus]/tr*v[t_bus]*cos(t[f_bus]-t[t_bus]-as) + -b*v[f_bus]/tr*v[t_bus]*sin(t[f_bus]-t[t_bus]-as)\nq[f_idx] == -(b+b_fr)*(v[f_bus]/tr)^2 + b*v[f_bus]/tr*v[t_bus]*cos(t[f_bus]-t[t_bus]-as) + -g*v[f_bus]/tr*v[t_bus]*sin(t[f_bus]-t[t_bus]-as)\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ohms_y_to","page":"Constraints","title":"PowerModels.constraint_ohms_y_to","text":"Creates Ohms constraints for AC models (y post fix indicates that Y values are in rectangular form)\n\np[t_idx] ==  (g+g_to)*v[t_bus]^2 + -g*v[t_bus]*v[f_bus]/tr*cos(t[t_bus]-t[f_bus]+as) + -b*v[t_bus]*v[f_bus]/tr*sin(t[t_bus]-t[f_bus]+as)\nq[t_idx] == -(b+b_to)*v[t_bus]^2 +  b*v[t_bus]*v[f_bus]/tr*cos(t[f_bus]-t[t_bus]+as) + -g*v[t_bus]*v[f_bus]/tr*sin(t[t_bus]-t[f_bus]+as)\n\n\n\n\n\n","category":"function"},{"location":"constraints/#On/Off-Ohm's-Law-Constraints","page":"Constraints","title":"On/Off Ohm's Law Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_ohms_yt_from_on_off\nconstraint_ohms_yt_to_on_off\nconstraint_ne_ohms_yt_from\nconstraint_ne_ohms_yt_to","category":"page"},{"location":"constraints/#PowerModels.constraint_ohms_yt_from_on_off","page":"Constraints","title":"PowerModels.constraint_ohms_yt_from_on_off","text":"p[f_idx] == z*(g/tm*v[f_bus]^2 + (-g*tr+b*ti)/tm^2*(v[f_bus]*v[t_bus]*cos(t[f_bus]-t[t_bus])) + (-b*tr-g*ti)/tm^2*(v[f_bus]*v[t_bus]*sin(t[f_bus]-t[t_bus])))\nq[f_idx] == z*(-(b+c/2)/tm*v[f_bus]^2 - (-b*tr-g*ti)/tm^2*(v[f_bus]*v[t_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr+b*ti)/tm^2*(v[f_bus]*v[t_bus]*sin(t[f_bus]-t[t_bus])))\n\n\n\n\n\n-b*(t[f_bus] - t[t_bus] + vad_min*(1-z_branch[i])) <= p[f_idx] <= -b*(t[f_bus] - t[t_bus] + vad_max*(1-z_branch[i]))\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\np[f_idx] ==        g/tm*w_fr[i] + (-g*tr+b*ti)/tm*(wr[i]) + (-b*tr-g*ti)/tm*(wi[i])\nq[f_idx] == -(b+c/2)/tm*w_fr[i] - (-b*tr-g*ti)/tm*(wr[i]) + (-g*tr+b*ti)/tm*(wi[i])\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ohms_yt_to_on_off","page":"Constraints","title":"PowerModels.constraint_ohms_yt_to_on_off","text":"p[t_idx] == z*(g*v[t_bus]^2 + (-g*tr-b*ti)/tm^2*(v[t_bus]*v[f_bus]*cos(t[t_bus]-t[f_bus])) + (-b*tr+g*ti)/tm^2*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus])))\nq[t_idx] == z*(-(b+c/2)*v[t_bus]^2 - (-b*tr+g*ti)/tm^2*(v[t_bus]*v[f_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr-b*ti)/tm^2*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus])))\n\n\n\n\n\nnothing to do, this model is symetric\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\np[t_idx] ==        g*w_to[i] + (-g*tr-b*ti)/tm*(wr[i]) + (-b*tr+g*ti)/tm*(-wi[i])\nq[t_idx] == -(b+c/2)*w_to[i] - (-b*tr+g*ti)/tm*(wr[i]) + (-g*tr-b*ti)/tm*(-wi[i])\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ne_ohms_yt_from","page":"Constraints","title":"PowerModels.constraint_ne_ohms_yt_from","text":"p_ne[f_idx] == z*(g/tm*v[f_bus]^2 + (-g*tr+b*ti)/tm^2*(v[f_bus]*v[t_bus]*cos(t[f_bus]-t[t_bus])) + (-b*tr-g*ti)/tm^2*(v[f_bus]*v[t_bus]*sin(t[f_bus]-t[t_bus])))\nq_ne[f_idx] == z*(-(b+c/2)/tm*v[f_bus]^2 - (-b*tr-g*ti)/tm^2*(v[f_bus]*v[t_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr+b*ti)/tm^2*(v[f_bus]*v[t_bus]*sin(t[f_bus]-t[t_bus])))\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\np[f_idx] == g/tm*w_fr_ne[i] + (-g*tr+b*ti)/tm*(wr_ne[i]) + (-b*tr-g*ti)/tm*(wi_ne[i])\nq[f_idx] == -(b+c/2)/tm*w_fr_ne[i] - (-b*tr-g*ti)/tm*(wr_ne[i]) + (-g*tr+b*ti)/tm*(wi_ne[i])\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ne_ohms_yt_to","page":"Constraints","title":"PowerModels.constraint_ne_ohms_yt_to","text":"p_ne[t_idx] == z*(g*v[t_bus]^2 + (-g*tr-b*ti)/tm^2*(v[t_bus]*v[f_bus]*cos(t[t_bus]-t[f_bus])) + (-b*tr+g*ti)/tm^2*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus])))\nq_ne[t_idx] == z*(-(b+c/2)*v[t_bus]^2 - (-b*tr+g*ti)/tm^2*(v[t_bus]*v[f_bus]*cos(t[f_bus]-t[t_bus])) + (-g*tr-b*ti)/tm^2*(v[t_bus]*v[f_bus]*sin(t[t_bus]-t[f_bus])))\n\n\n\n\n\nnothing to do, this model is symetric\n\n\n\n\n\nCreates Ohms constraints (yt post fix indicates that Y and T values are in rectangular form)\n\np[t_idx] == g*w_to_ne[i] + (-g*tr-b*ti)/tm*(wr_ne[i]) + (-b*tr+g*ti)/tm*(-wi_ne[i])\nq[t_idx] == -(b+c/2)*w_to_ne[i] - (-b*tr+g*ti)/tm*(wr_ne[i]) + (-g*tr-b*ti)/tm*(-wi_ne[i])\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Current","page":"Constraints","title":"Current","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_current_balance\nconstraint_power_magnitude_sqr\nconstraint_power_magnitude_sqr_on_off\nconstraint_power_magnitude_link\nconstraint_power_magnitude_link_on_off","category":"page"},{"location":"constraints/#PowerModels.constraint_current_balance","page":"Constraints","title":"PowerModels.constraint_current_balance","text":"Kirchhoff's current law applied to buses sum(cr + im*ci) = 0\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_power_magnitude_sqr","page":"Constraints","title":"PowerModels.constraint_power_magnitude_sqr","text":"p[f_idx]^2 + q[f_idx]^2 <= w[f_bus]/tm*cm[f_bus,t_bus]\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_power_magnitude_sqr_on_off","page":"Constraints","title":"PowerModels.constraint_power_magnitude_sqr_on_off","text":"p[arc_from]^2 + q[arc_from]^2 <= w[f_bus]/tm*cm[i]\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_power_magnitude_link","page":"Constraints","title":"PowerModels.constraint_power_magnitude_link","text":"cm[f_bus,t_bus] == (g^2 + b^2)*(w[f_bus]/tm + w[t_bus] - 2*(tr*wr[f_bus,t_bus] + ti*wi[f_bus,t_bus])/tm) - c*q[f_idx] - ((c/2)/tm)^2*w[f_bus]\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_power_magnitude_link_on_off","page":"Constraints","title":"PowerModels.constraint_power_magnitude_link_on_off","text":"ccm[f_bus,t_bus] == (g^2 + b^2)*(w[f_bus]/tm + w[t_bus] - 2*(tr*wr[f_bus,t_bus] + ti*wi[f_bus,t_bus])/tm) - c*q[f_idx] - ((c/2)/tm)^2*w[f_bus]\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Thermal-Limit-Constraints","page":"Constraints","title":"Thermal Limit Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_thermal_limit_from\nconstraint_thermal_limit_to\nconstraint_thermal_limit_from_on_off\nconstraint_thermal_limit_to_on_off\nconstraint_ne_thermal_limit_from\nconstraint_ne_thermal_limit_to","category":"page"},{"location":"constraints/#PowerModels.constraint_thermal_limit_from","page":"Constraints","title":"PowerModels.constraint_thermal_limit_from","text":"constraint_thermal_limit_from(pm::AbstractPowerModel, n::Int, i::Int)\n\nAdds the (upper and lower) thermal limit constraints for the desired branch to the PowerModel.\n\n\n\n\n\np[f_idx]^2 + q[f_idx]^2 <= rate_a^2\n\n\n\n\n\n[rate_a, p[f_idx], q[f_idx]] in SecondOrderCone\n\n\n\n\n\np[f_idx]^2 + q[f_idx]^2 <= rate_a^2\n\n\n\n\n\n-rate_a <= p[f_idx] <= rate_a\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_thermal_limit_to","page":"Constraints","title":"PowerModels.constraint_thermal_limit_to","text":"p[t_idx]^2 + q[t_idx]^2 <= rate_a^2\n\n\n\n\n\n[rate_a, p[t_idx], q[t_idx]] in SecondOrderCone\n\n\n\n\n\np[t_idx]^2 + q[t_idx]^2 <= rate_a^2\n\n\n\n\n\nnothing to do, this model is symetric\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_thermal_limit_from_on_off","page":"Constraints","title":"PowerModels.constraint_thermal_limit_from_on_off","text":"p[f_idx]^2 + q[f_idx]^2 <= (rate_a * z_branch[i])^2\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_thermal_limit_to_on_off","page":"Constraints","title":"PowerModels.constraint_thermal_limit_to_on_off","text":"p[t_idx]^2 + q[t_idx]^2 <= (rate_a * z_branch[i])^2\n\n\n\n\n\nnothing to do, this model is symetric\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ne_thermal_limit_from","page":"Constraints","title":"PowerModels.constraint_ne_thermal_limit_from","text":"p_ne[f_idx]^2 + q_ne[f_idx]^2 <= (rate_a * branch_ne[i])^2\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ne_thermal_limit_to","page":"Constraints","title":"PowerModels.constraint_ne_thermal_limit_to","text":"p_ne[t_idx]^2 + q_ne[t_idx]^2 <= (rate_a * branch_ne[i])^2\n\n\n\n\n\nnothing to do, this model is symetric\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Current-Limit-Constraints","page":"Constraints","title":"Current Limit Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_current_limit\nconstraint_current_to\nconstraint_current_from","category":"page"},{"location":"constraints/#PowerModels.constraint_current_to","page":"Constraints","title":"PowerModels.constraint_current_to","text":"Defines how current distributes over series and shunt impedances of a pi-model branch\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_current_from","page":"Constraints","title":"PowerModels.constraint_current_from","text":"Defines how current distributes over series and shunt impedances of a pi-model branch\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Phase-Angle-Difference-Constraints","page":"Constraints","title":"Phase Angle Difference Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_voltage_angle_difference\nconstraint_voltage_angle_difference_on_off\nconstraint_ne_voltage_angle_difference","category":"page"},{"location":"constraints/#PowerModels.constraint_voltage_angle_difference","page":"Constraints","title":"PowerModels.constraint_voltage_angle_difference","text":"Bounds the voltage angle difference between bus pairs\n\n\n\n\n\nbranch voltage angle difference bounds\n\n\n\n\n\nt[f_bus] - t[t_bus] <= angmax\nt[f_bus] - t[t_bus] >= angmin\n\n\n\n\n\nnothing to do, no voltage angle variables\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_voltage_angle_difference_on_off","page":"Constraints","title":"PowerModels.constraint_voltage_angle_difference_on_off","text":"angmin <= z_branch[i]*(t[f_bus] - t[t_bus]) <= angmax\n\n\n\n\n\nangmin*z_branch[i] + vad_min*(1-z_branch[i]) <= t[f_bus] - t[t_bus] <= angmax*z_branch[i] + vad_max*(1-z_branch[i])\n\n\n\n\n\nangmin*z_branch[i] + vad_min*(1-z_branch[i]) <= t[f_bus] - t[t_bus] <= angmax*z_branch[i] + vad_max*(1-z_branch[i])\n\n\n\n\n\nangmin*wr[i] <= wi[i] <= angmax*wr[i]\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_ne_voltage_angle_difference","page":"Constraints","title":"PowerModels.constraint_ne_voltage_angle_difference","text":"angmin <= branch_ne[i]*(t[f_bus] - t[t_bus]) <= angmax\n\n\n\n\n\nangmin*branch_ne[i] + vad_min*(1-branch_ne[i]) <= t[f_bus] - t[t_bus] <= angmax*branch_ne[i] + vad_max*(1-branch_ne[i])\n\n\n\n\n\nangmin*branch_ne[i] + vad_min*(1-branch_ne[i]) <= t[f_bus] - t[t_bus] <= angmax*branch_ne[i] + vad_max*(1-branch_ne[i])\n\n\n\n\n\nangmin*wr_ne[i] <= wi_ne[i] <= angmax*wr_ne[i]\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Loss-Constraints","page":"Constraints","title":"Loss Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_power_losses\nconstraint_power_losses_lb\nconstraint_voltage_magnitude_difference\nconstraint_voltage_drop","category":"page"},{"location":"constraints/#PowerModels.constraint_power_losses","page":"Constraints","title":"PowerModels.constraint_power_losses","text":"Defines branch flow model power flow equations\n\n\n\n\n\nDefines linear branch flow model power flow equations\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_power_losses_lb","page":"Constraints","title":"PowerModels.constraint_power_losses_lb","text":"p[f_idx] + p[t_idx] >= 0\nq[f_idx] + q[t_idx] >= -c/2*(v[f_bus]^2/tr^2 + v[t_bus]^2)\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_voltage_magnitude_difference","page":"Constraints","title":"PowerModels.constraint_voltage_magnitude_difference","text":"Defines voltage drop over a branch, linking from and to side voltage magnitude\n\n\n\n\n\nDefines voltage drop over a branch, linking from and to side voltage magnitude\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_voltage_drop","page":"Constraints","title":"PowerModels.constraint_voltage_drop","text":"Defines voltage drop over a branch, linking from and to side complex voltage\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Storage-Constraints","page":"Constraints","title":"Storage Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_storage_thermal_limit\nconstraint_storage_current_limit\nconstraint_storage_complementarity_nl\nconstraint_storage_complementarity_mi\nconstraint_storage_losses\nconstraint_storage_state_initial\nconstraint_storage_state","category":"page"},{"location":"constraints/#PowerModels.constraint_storage_losses","page":"Constraints","title":"PowerModels.constraint_storage_losses","text":"Neglects the active and reactive loss terms associated with the squared current magnitude.\n\n\n\n\n\n","category":"function"},{"location":"constraints/#DC-Line-Constraints","page":"Constraints","title":"DC Line Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_dcline_power_losses\nconstraint_dcline_setpoint_active","category":"page"},{"location":"constraints/#PowerModels.constraint_dcline_power_losses","page":"Constraints","title":"PowerModels.constraint_dcline_power_losses","text":"Creates Line Flow constraint for DC Lines (Matpower Formulation)\n\np_fr + p_to == loss0 + p_fr * loss1\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_dcline_setpoint_active","page":"Constraints","title":"PowerModels.constraint_dcline_setpoint_active","text":"pf[i] == pf, pt[i] == pt\n\n\n\n\n\np_fr[i] == pref_fr, p_to[i] == pref_to\n\n\n\n\n\n","category":"function"},{"location":"constraints/#Switch-Constraints","page":"Constraints","title":"Switch Constraints","text":"","category":"section"},{"location":"constraints/","page":"Constraints","title":"Constraints","text":"constraint_switch_state\nconstraint_switch_on_off\nconstraint_switch_thermal_limit","category":"page"},{"location":"constraints/#PowerModels.constraint_switch_state","page":"Constraints","title":"PowerModels.constraint_switch_state","text":"enforces static switch constraints\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_switch_on_off","page":"Constraints","title":"PowerModels.constraint_switch_on_off","text":"enforces controlable switch constraints\n\n\n\n\n\n","category":"function"},{"location":"constraints/#PowerModels.constraint_switch_thermal_limit","page":"Constraints","title":"PowerModels.constraint_switch_thermal_limit","text":"enforces an mva limit on the power flow over a switch\n\n\n\n\n\n","category":"function"},{"location":"multi-networks/#Working-with-Multi-Network-Data","page":"Multi Networks","title":"Working with Multi-Network Data","text":"","category":"section"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"import Pkg\nusing PowerModels\n\ncase3file = Pkg.dir(dirname(@__DIR__), \"test\", \"data\", \"matpower\", \"case3.m\")","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"There are occasions when it is desirable to co-optimize multiple networks, these networks might encode time for dynamic network optimization, or scenarios for stochastic optimization.","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"To distinguish between network data (see The Network Data Dictionary) that correspond to a single network or to multiple networks, PowerModels.jl provides the function ismultinetwork().  For example, we can do the following:","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"println(case3file)\nnetwork_data = PowerModels.parse_file(case3file)\npm = instantiate_model(network_data, ACPPowerModel, PowerModels.build_opf)\n\nPowerModels.ismultinetwork(pm)","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"PowerModels.jl would generally not read in network data as multi-networks. To generate multiple networks from the same network data, we use the following method","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"PowerModels.replicate","category":"page"},{"location":"multi-networks/#PowerModels.replicate","page":"Multi Networks","title":"PowerModels.replicate","text":"Turns in given single network data in multinetwork data with a count replicate of the given network.  Note that this function performs a deepcopy of the network data.  Significant multinetwork space savings can often be achieved by building application specific methods of building multinetwork with minimal data replication.\n\n\n\n\n\n","category":"function"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"For example, we can make three replicates by calling","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"network_data3 = PowerModels.replicate(network_data, 3)","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"Observe that the structure of network_data3 is different from that of network_data, since it is a multi-network. The user can then modify each replicate of the network to vary in the corresponding parameter of interest. See test/common.jl for examples on setting up valid Multi-Network data.","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"To build a PowerModel from a multinetwork data dictionary (see Building PowerModels from Network Data Dictionaries), we supply multinetwork=true during the call to build_generic_model and replace build_opf with build_mn_opf,","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"pm3 = PowerModels.instantiate_model(network_data3, ACPPowerModel, PowerModels.build_mn_opf, multinetwork=true)\n\nPowerModels.ismultinetwork(pm3)","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"note: Note\nThe replicate() method only works on single networks. Sodata33 = PowerModels.replicate(data3, 3)will result in an error. Moreover, instantiate_model() (see )","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"Because this is a common pattern of usage, we provide corresponding calls to solve_mn_opf (which behaves analogously to solve_opf, but for multinetwork data).","category":"page"},{"location":"multi-networks/","page":"Multi Networks","title":"Multi Networks","text":"note: Note\nWorking with Multi-Networks is for advanced users, and those who are interested should refer to src/prob/test.jl for toy problem formulations for multi-network and multi-conductor models.","category":"page"},{"location":"storage/#PowerModels'-Storage-Component","page":"Storage Model","title":"PowerModels' Storage Component","text":"","category":"section"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"In addition to the standard transmission network components (e.g. bus, load, generator, branch, ...) PowerModels also includes a generic storage component, which can be configured to model a variety of storage devices.  This section provides a brief overview of the storage component's data and mathematical model.  The motivations and derivation of this model are discussed in this technical report.","category":"page"},{"location":"storage/#Storage-Data-Model","page":"Storage Model","title":"Storage Data Model","text":"","category":"section"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"When parsing a matpower file with storage information, ","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"data = PowerModels.parse_file(\"matpower/case5_strg.m\")","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"the storage information can be retrieved via the \"storage\" keyword in the data dictionary. They will be correspondingly rendered when PowerModels.print_summary(data) or PowerModels.component_table(data, \"storage\", <columns>) is called.","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"The list of columns for the generic storage model is roughly as follows,","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"{\n  \"index\":<int>,\n  \"storage_bus\":<int>,\n  \"ps\":<float, MW>,\n  \"qs\":<float, MVAr>,\n  \"energy\":<float, MWh>,\n  \"energy_rating\":<float, MWh>,\n  \"charge_rating\":<float, MW>,\n  \"discharge_rating\":<float, MW>,\n  \"charge_efficiency\":<float>,\n  \"discharge_efficiency\":<float>,\n  (\"thermal_rating\":<float, MVA>,)\n  (\"current_rating\":<float, MA>,)\n  \"qmin\":<float, MVar>,\n  \"qmax\":<float, MVar>,\n  \"r\":<float, p.u.>,\n  \"x\":<float, p.u.>,\n  \"p_loss\":<float, MW>,\n  \"q_loss\":<float, MVar>,\n  \"status\":<int>,\n}","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"All of these quantities should be positive except for qmin,p_loss and q_loss, which can be negative.  The efficiency parameters are unit-less scalars in the range of 1.0 and 0.0.  By default, all of these quantities are used in per unit inside PowerModels.  The units indicated here are only used by PowerModels' mixed-unit representation and the extended Matpower network format.","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"Note that the optional thermal_rating and current_rating parameters are applied at the point of coupling to the network while the other ratings are internal to the storage device.","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"In addition to these component parameters, PowerModels also requires a global parameter time_elapsed (in hours) to specify how active power is converted into units of energy as the storage device is charged or discharged.","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"PowerModels' storage components can be added to Matpower data files as follows,","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"% hours\nmpc.time_elapsed = 1.0\n\n%% storage data\n%   storage_bus ps  qs  energy  energy_rating charge_rating  discharge_rating  charge_efficiency  discharge_efficiency  thermal_rating  qmin  qmax  r  x  p_loss  p_loss  status\nmpc.storage = [\n   3   0.0  0.0  20.0  100.0   50.0  70.0  0.8   0.9   100.0   -50.0   70.0  0.1   0.0   0.0   0.0   1;\n   10  0.0  0.0  30.0  100.0   50.0  70.0  0.9   0.8   100.0   -50.0   70.0  0.1   0.0   0.0   0.0   1;\n];","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"Note that this Matpower-based format includes the optional thermal_rating parameter.","category":"page"},{"location":"storage/#Storage-Mathematical-Model","page":"Storage Model","title":"Storage Mathematical Model","text":"","category":"section"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"Given the storage data model and two sequential time points s and t, the storage component's mathematical model is given by,","category":"page"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"beginalign\n\nmboxdata   nonumber \n e^u mbox - energy rating nonumber \n sc^u mbox - charge rating nonumber \n sd^u mbox - discharge rating nonumber \n eta^c mbox - charge efficiency nonumber \n eta^d mbox - discharge efficiency nonumber \n te mbox - time elapsed nonumber \n S^l mbox - power losses nonumber \n Z mbox - injection impedance nonumber \n q^l q^u  mbox - reactive power injection limits nonumber \n s^u mbox - thermal injection limit nonumber \n i^u mbox - current injection limit nonumber \n\nmboxvariables   nonumber \n e_i in (0 e^u) mbox - storage energy at time i labelvar_strg_energy \n sc_i in (0 sc^u) mbox - charge amount at time i labelvar_strg_charge \n sd_i in (0 sd^u) mbox - discharge amount at time i labelvar_strg_discharge \n sqc_i mbox - reactive power slack at time i labelvar_strg_qslack \n S_i mbox - complex bus power injection at time i labelvar_strg_power \n I_i mbox - complex bus current injection at time i labelvar_strg_current \n\nmboxsubject to   nonumber \n e_t - e_s = te left(eta^c sc_t - fracsd_teta^d right) labeleq_strg_energy \n sc_t cdot sd_t = 0 labeleq_strg_compl \n S_t + (sd_t - sc_t) = j cdot sqc_t + S^l + Z I_t^2 labeleq_strg_loss \n q^l leq Im(S_t) leq q^u labeleq_strg_q_limit \n S_t leq s^u labeleq_strg_thermal_limit \n I_t leq i^u labeleq_strg_current_limit\nendalign","category":"page"},{"location":"storage/#Mapping-to-PowerModels-Functions","page":"Storage Model","title":"Mapping to PowerModels Functions","text":"","category":"section"},{"location":"storage/","page":"Storage Model","title":"Storage Model","text":"Eq. eqrefvar_strg_energy - variable_storage_energy\nEq. eqrefvar_strg_charge - variable_storage_charge\nEq. eqrefvar_strg_discharge - variable_storage_discharge\nEq. eqrefvar_strg_qslack - variable_storage_power_control_imaginary\nEq. eqrefvar_strg_power - variable_storage_power\nEq. eqrefvar_strg_current - implemented as a function of other variables\nEq. eqrefeq_strg_energy - constraint_storage_state\nEq. eqrefeq_strg_compl - constraint_storage_complementarity_nl or constraint_storage_complementarity_mi\nEq. eqrefeq_strg_loss - constraint_storage_losses\nEq. eqrefeq_strg_q_limit - bounds of variable_storage_power\nEq. eqrefeq_strg_thermal_limit - constraint_storage_thermal_limit\nEq. eqrefeq_strg_current_limit - constraint_storage_current_limit","category":"page"},{"location":"model/#Power-Model","page":"PowerModel","title":"Power Model","text":"","category":"section"},{"location":"model/","page":"PowerModel","title":"PowerModel","text":"CurrentModule = PowerModels","category":"page"},{"location":"model/","page":"PowerModel","title":"PowerModel","text":"All methods for constructing powermodels should be defined on the following type:","category":"page"},{"location":"model/","page":"PowerModel","title":"PowerModel","text":"AbstractPowerModel","category":"page"},{"location":"model/#PowerModels.AbstractPowerModel","page":"PowerModel","title":"PowerModels.AbstractPowerModel","text":"root of the power formulation type hierarchy\n\n\n\n\n\n","category":"type"},{"location":"model/","page":"PowerModel","title":"PowerModel","text":"which utilizes the following (internal) functions:","category":"page"},{"location":"model/","page":"PowerModel","title":"PowerModel","text":"build_ref\ncalc_buspair_parameters","category":"page"},{"location":"model/#PowerModels.build_ref","page":"PowerModel","title":"PowerModels.build_ref","text":"used for building ref without the need to build a initialize an AbstractPowerModel\n\n\n\n\n\n","category":"function"},{"location":"model/#PowerModels.calc_buspair_parameters","page":"PowerModel","title":"PowerModels.calc_buspair_parameters","text":"compute bus pair level data, can be run on data or ref data structures\n\n\n\n\n\n","category":"function"},{"location":"specifications/#Problem-Specifications","page":"Problem Specifications","title":"Problem Specifications","text":"","category":"section"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"This section provides links to the formulation agnostic problem specifications.","category":"page"},{"location":"specifications/#Power-Flow-(PF)","page":"Problem Specifications","title":"Power Flow (PF)","text":"","category":"section"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"For additional discussion on the power flow problem please see, Power Flow Computations.","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"Bus Injection Models (BIM)","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"build_pf","category":"page"},{"location":"specifications/#PowerModels.build_pf","page":"Problem Specifications","title":"PowerModels.build_pf","text":"specification of the formulation agnostic Power Flow model\n\n\n\n\n\n","category":"function"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"Branch Flow Models (BFM)","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"build_pf_bf","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"Current Flow Models (CFM)","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"build_pf_iv","category":"page"},{"location":"specifications/#Optimal-Power-Flow-(OPF)","page":"Problem Specifications","title":"Optimal Power Flow (OPF)","text":"","category":"section"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"Bus Injection Models (BIM)","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"build_opf\nbuild_mn_opf\nbuild_mn_opf_strg\nbuild_opf_ptdf","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"Branch Flow Models (BFM)","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"build_opf_bf\nbuild_mn_opf_bf_strg","category":"page"},{"location":"specifications/#PowerModels.build_mn_opf_bf_strg","page":"Problem Specifications","title":"PowerModels.build_mn_opf_bf_strg","text":"Build multinetwork branch flow storage OPF\n\n\n\n\n\n","category":"function"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"Current Flow Models (CFM)","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"build_opf_iv","category":"page"},{"location":"specifications/#Optimal-Power-Balance-(OPB)","page":"Problem Specifications","title":"Optimal Power Balance (OPB)","text":"","category":"section"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"A copper-plate approximation of the OPF problem","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"build_opb","category":"page"},{"location":"specifications/#Optimal-Transmission-Switching-(OTS)","page":"Problem Specifications","title":"Optimal Transmission Switching (OTS)","text":"","category":"section"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"build_ots","category":"page"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"note: Note\nif the branch status is 0 in the input, it is out of service and forced to 0 in OTS","category":"page"},{"location":"specifications/#Transmission-Network-Expansion-Planning-(TNEP)","page":"Problem Specifications","title":"Transmission Network Expansion Planning (TNEP)","text":"","category":"section"},{"location":"specifications/","page":"Problem Specifications","title":"Problem Specifications","text":"build_tnep","category":"page"},{"location":"specifications/#PowerModels.build_tnep","page":"Problem Specifications","title":"PowerModels.build_tnep","text":"the general form of the tnep optimization model\n\n\n\n\n\n","category":"function"},{"location":"result-data/#PowerModels-Result-Data-Format","page":"Result Data Format","title":"PowerModels Result Data Format","text":"","category":"section"},{"location":"result-data/#The-Result-Data-Dictionary","page":"Result Data Format","title":"The Result Data Dictionary","text":"","category":"section"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"PowerModels utilizes a dictionary to organize the results of a run command. The dictionary uses strings as key values so it can be serialized to JSON for algorithmic data exchange. The data dictionary organization is designed to be consistent with the PowerModels The Network Data Dictionary.","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"At the top level the results data dictionary is structured as follows:","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"{\n\"optimizer\":<string>,    # name of the Julia class used to solve the model\n\"termination_status\":<TerminationStatusCode enum>, # optimizer status at termination\n\"primal_status\":<ResultStatusCode enum>, # the primal solution status at termination\n\"dual_status\":<ResultStatusCode enum>, # the dual solution status at termination\n\"solve_time\":<float>,    # reported solve time (seconds)\n\"objective\":<float>,     # the final evaluation of the objective function\n\"objective_lb\":<float>,  # the final lower bound of the objective function (if available)\n\"solution\":{...}         # complete solution information (details below)\n}","category":"page"},{"location":"result-data/#Solution-Data","page":"Result Data Format","title":"Solution Data","text":"","category":"section"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"The solution object provides detailed information about the solution produced by the solve command. The solution is organized similarly to The Network Data Dictionary with the same nested structure and parameter names, when available.  A network solution most often only includes a small subset of the data included in the network data.","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"For example the data for a bus, data[\"bus\"][\"1\"] is structured as follows,","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"{\n\"bus_type\":2\n\"vmin\":0.9\n\"vmax\":1.1\n\"vm\":1.0,\n\"va\":0.0,\n...\n}","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"A solution specifying a voltage magnitude and angle would for the same case, i.e. result[\"solution\"][\"bus\"][\"1\"], would result in,","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"{\n\"vm\":1.12,\n\"va\":-3.59,\n}","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"A table-like text summary of the solution data can be generated using the standard data summary function as follows,","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"PowerModels.print_summary(result[\"solution\"])","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"Because the data dictionary and the solution dictionary have the same structure PowerModels provides an update_data! helper function which can be used to update a data dictionary with the values from a solution as follows,","category":"page"},{"location":"result-data/","page":"Result Data Format","title":"Result Data Format","text":"PowerModels.update_data!(data, result[\"solution\"])","category":"page"},{"location":"formulations/#Network-Formulations","page":"Network Formulations","title":"Network Formulations","text":"","category":"section"},{"location":"formulations/#Type-Hierarchy","page":"Network Formulations","title":"Type Hierarchy","text":"","category":"section"},{"location":"formulations/","page":"Network Formulations","title":"Network Formulations","text":"We begin with the top of the hierarchy, where we can distinguish between AC and DC power flow models.","category":"page"},{"location":"formulations/","page":"Network Formulations","title":"Network Formulations","text":"AbstractACPModel <: AbstractPowerModel\nAbstractDCPModel <: AbstractPowerModel\nAbstractWRModel <: AbstractPowerModel\nAbstractWModel <: AbstractPowerModel\nAbstractIVRModel <: AbstractPowerModel","category":"page"},{"location":"formulations/#Power-Models","page":"Network Formulations","title":"Power Models","text":"","category":"section"},{"location":"formulations/","page":"Network Formulations","title":"Network Formulations","text":"Each of these forms can be used as the model parameter for a PowerModel:","category":"page"},{"location":"formulations/","page":"Network Formulations","title":"Network Formulations","text":"ACPPowerModel <: AbstractACPForm\n\nDCPPowerModel <: AbstractDCPForm\n\nIVRPowerModel <: AbstractIVRModel\n\nSOCWRPowerModel <: AbstractWRForm\nQCRMPowerModel <: AbstractWRForm\n\nSOCBFPowerModel <: AbstractSOCBFModel","category":"page"},{"location":"formulations/","page":"Network Formulations","title":"Network Formulations","text":"For details on AbstractPowerModel, see the section on Power Model.  A more comprehensive list of supported formulation is documented in Formulation Details.","category":"page"},{"location":"formulations/#User-Defined-Abstractions","page":"Network Formulations","title":"User-Defined Abstractions","text":"","category":"section"},{"location":"formulations/","page":"Network Formulations","title":"Network Formulations","text":"Consider the class of conic Models for power flow models. One way of modeling them in this package is through the following type hierarchy:","category":"page"},{"location":"formulations/","page":"Network Formulations","title":"Network Formulations","text":"AbstractConicPowerModel <: AbstractPowerModel\nAbstractWRMModel <: AbstractConicPowerModel\n\nAbstractSDPWRMModel <: AbstractWRMModel\nmutable struct SDPWRMPowerModel <: AbstractSDPWRMModel @pm_fields end","category":"page"},{"location":"formulations/","page":"Network Formulations","title":"Network Formulations","text":"The user-defined abstractions do not have to begin from the root AbstractPowerModel abstract type, and can begin from an intermediate abstract type. For example, in the following snippet:","category":"page"},{"location":"formulations/","page":"Network Formulations","title":"Network Formulations","text":"AbstractDCPLLModel <: AbstractDCPModel\n\nmutable struct DCPLLPowerModel <: AbstractDCPLLModel @pm_fields end","category":"page"},{"location":"variables/#Variables","page":"Variables","title":"Variables","text":"","category":"section"},{"location":"variables/","page":"Variables","title":"Variables","text":"We provide the following methods to provide a compositional approach for defining common variables used in power flow models. These methods should always be defined over \"AbstractPowerModel\".","category":"page"},{"location":"variables/","page":"Variables","title":"Variables","text":"Modules = [PowerModels]\nPages   = [\"core/variable.jl\"]\nOrder   = [:type, :function]\nPrivate  = true","category":"page"},{"location":"variables/#PowerModels.sol_component_value_buspair-Tuple{AbstractPowerModel, Int64, Symbol, Symbol, Any, Any}","page":"Variables","title":"PowerModels.sol_component_value_buspair","text":"map sparse buspair variables into components\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_current_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_current_imaginary","text":"variable: ci[l,i,j] for (l,i,j) in arcs\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_current_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_current_real","text":"variable: cr[l,i,j] for (l,i,j) in arcs\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_indicator-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_indicator","text":"variable: 0 <= z_branch[l] <= 1 for l in branches\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_power_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_power_imaginary","text":"variable: q[l,i,j] for (l,i,j) in arcs\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_power_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_power_real","text":"variable: p[l,i,j] for (l,i,j) in arcs\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_series_current_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_series_current_imaginary","text":"variable: csi[l,i,j] for (l,i,j) in arcs_from\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_series_current_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_series_current_real","text":"variable: csr[l,i,j] for (l,i,j) in arcs_from\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_transform_angle-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_transform_angle","text":"variable: ta[l] for l in branches\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_transform_magnitude-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_transform_magnitude","text":"variable: 0 <= tm[l] for l in branches\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_voltage_magnitude_fr_on_off-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_voltage_magnitude_fr_on_off","text":"variable: 0 <= vm_fr[l] <= buses[branches[l][\"f_bus\"]][\"vmax\"] for l in branches\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_voltage_magnitude_fr_sqr_on_off-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_voltage_magnitude_fr_sqr_on_off","text":"variable: 0 <= w_fr[l] <= buses[branches[l][\"f_bus\"]][\"vmax\"]^2 for l in branches\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_voltage_magnitude_to_on_off-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_voltage_magnitude_to_on_off","text":"variable: 0 <= vm_to[l] <= buses[branches[l][\"t_bus\"]][\"vmax\"] for l in branches\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_branch_voltage_magnitude_to_sqr_on_off-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_branch_voltage_magnitude_to_sqr_on_off","text":"variable: 0 <= w_to[l] <= buses[branches[l][\"t_bus\"]][\"vmax\"]^2 for l in branches\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_bus_voltage_angle-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_bus_voltage_angle","text":"variable: t[i] for i in buses\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_bus_voltage_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_bus_voltage_imaginary","text":"real part of the voltage variable i in buses\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_bus_voltage_magnitude-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_bus_voltage_magnitude","text":"variable: v[i] for i in buses\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_bus_voltage_magnitude_sqr-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_bus_voltage_magnitude_sqr","text":"variable: w[i] >= 0 for i in buses\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_bus_voltage_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_bus_voltage_real","text":"real part of the voltage variable i in buses\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_dcline_current_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_dcline_current_imaginary","text":"variable:  cidc[j] for j in dcline\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_dcline_current_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_dcline_current_real","text":"variable: crdc[j] for j in dcline\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_dcline_power_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_dcline_power_imaginary","text":"variable: q_dc[l,i,j] for (l,i,j) in arcs_dc\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_dcline_power_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_dcline_power_real","text":"variable: p_dc[l,i,j] for (l,i,j) in arcs_dc\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_gen_current_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_gen_current_imaginary","text":"variable: cig[j] for j in gen\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_gen_current_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_gen_current_real","text":"variable: crg[j] for j in gen\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_gen_power-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_gen_power","text":"generates variables for both active and reactive generation\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_gen_power_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_gen_power_imaginary","text":"variable: qq[j] for j in gen\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_gen_power_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_gen_power_real","text":"variable: pg[j] for j in gen\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_ne_branch_indicator-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_ne_branch_indicator","text":"variable: 0 <= branch_ne[l] <= 1 for l in branches\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_ne_branch_power-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_ne_branch_power","text":"generates variables for both active and reactive branch_flow_ne\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_ne_branch_power_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_ne_branch_power_imaginary","text":"variable: -ne_branch[l][\"rate_a\"] <= q_ne[l,i,j] <= ne_branch[l][\"rate_a\"] for (l,i,j) in ne_arcs\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_ne_branch_power_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_ne_branch_power_real","text":"variable: -ne_branch[l][\"rate_a\"] <= p_ne[l,i,j] <= ne_branch[l][\"rate_a\"] for (l,i,j) in ne_arcs\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_storage_current-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_storage_current","text":"do nothing by default but some formulations require this\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_storage_power-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_storage_power","text":"variables for modeling storage units, includes grid injection and internal variables\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_storage_power_control_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_storage_power_control_imaginary","text":"a reactive power slack variable that enables the storage device to inject or consume reactive power at its connecting bus, subject to the injection limits of the device.\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_storage_power_control_imaginary_on_off-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_storage_power_control_imaginary_on_off","text":"a reactive power slack variable that enables the storage device to inject or consume reactive power at its connecting bus, subject to the injection limits of the device.\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_storage_power_mi-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_storage_power_mi","text":"variables for modeling storage units, includes grid injection and internal variables, with mixed int variables for charge/discharge\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_switch_power_imaginary-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_switch_power_imaginary","text":"variable: pws[l,i,j] for (l,i,j) in arcs_sw\n\n\n\n\n\n","category":"method"},{"location":"variables/#PowerModels.variable_switch_power_real-Tuple{AbstractPowerModel}","page":"Variables","title":"PowerModels.variable_switch_power_real","text":"variable: pws[l,i,j] for (l,i,j) in arcs_sw\n\n\n\n\n\n","category":"method"},{"location":"variables/","page":"Variables","title":"Variables","text":"variable_branch_current\nvariable_bus_voltage\nvariable_gen_current","category":"page"},{"location":"variables/#PowerModels.variable_bus_voltage","page":"Variables","title":"PowerModels.variable_bus_voltage","text":"nothing to do, no voltage angle variables\n\n\n\n\n\n","category":"function"},{"location":"switch/#PowerModels'-Switch-Component","page":"Switch Model","title":"PowerModels' Switch Component","text":"","category":"section"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"In addition to the standard transmission network components (e.g. bus, load, generator, branch, ...) PowerModels also includes a generic switch component, which can be used to model a variety of topology control devices (e.g. breakers, reclosers, fuses, ect...).  This section provides a brief overview of the switch component's data and mathematical model.","category":"page"},{"location":"switch/#Switch-Data-Model","page":"Switch Model","title":"Switch Data Model","text":"","category":"section"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"When parsing a matpower file with switch information, ","category":"page"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"data = PowerModels.parse_file(\"matpower/case5_sw.m\")","category":"page"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"the switch information can be retrieved via the \"switch\" keyword in the data dictionary. They will be correspondingly rendered when PowerModels.print_summary(data) or PowerModels.component_table(data, \"switch\", <columns>) is called.","category":"page"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"The list of columns for the generic switch model is roughly as follows,","category":"page"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"{\n  \"index\":<int>,\n  \"f_bus\":<int>,\n  \"r_bus\":<int>,\n  \"psw\":<float, MW>,\n  \"qsw\":<float, MVAr>,\n  \"state\":<int>,\n  (\"thermal_rating\":<float, MVA>,)\n  (\"current_rating\":<float, MA>,)\n  \"status\":<int>,\n}","category":"page"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"By default, all of these quantities are used in per unit inside PowerModels.  The units indicated here are only used by PowerModels' mixed-unit representation and the extended Matpower network format.","category":"page"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"PowerModels' switch components can be added to Matpower data files as follows,","category":"page"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"%% switch data\n% f_bus t_bus psw qsw state thermal_rating  status\nmpc.switch = [\n  1  2   300.0   98.61   1   1000.0  1;\n  3  2     0.0    0.00   0   1000.0  1;\n  3  4     0.0    0.00   1   1000.0  0;\n];","category":"page"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"Note that this Matpower-based format includes the optional thermal_rating parameter.","category":"page"},{"location":"switch/#Switch-Mathematical-Model","page":"Switch Model","title":"Switch Mathematical Model","text":"","category":"section"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"Switch component have two discrete states open (i.e. 0) and closed (i.e. 1).  When a switch is in the open state no power can flow between the connected buses through the switch.  When the switch is in the closed state power can flow freely between the connected buses (up to the provide flow limits) and the voltage at the two connecting buses should be the same.  The switch component's mathematical model is given by,","category":"page"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"beginalign\n\nmboxdata   nonumber \n s^u mbox - thermal injection limit nonumber \n i^u mbox - current injection limit nonumber \n\nmboxvariables   nonumber \n z in 0 1 mbox - the state of the switch (openclosed) labelvar_sw_state \n V_i mbox - complex voltage on bus i labelvar_sw_voltage_fr \n V_j mbox - complex voltage on bus j labelvar_sw_voltage_to \n S mbox - complex power flowing along the switch labelvar_sw_power \n\nmboxsubject to   nonumber \n z cdot V_i = z cdot V_j labeleq_sw_voltage \n S leq z cdot s^u labeleq_sw_thermal_limit \n I leq z cdot i^u labeleq_sw_current_limit\nendalign","category":"page"},{"location":"switch/#Mapping-to-PowerModels-Functions","page":"Switch Model","title":"Mapping to PowerModels Functions","text":"","category":"section"},{"location":"switch/","page":"Switch Model","title":"Switch Model","text":"Eq. eqrefvar_sw_state - variable_switch_indicator\nEq. eqrefvar_sw_voltage_fr - variable_bus_voltage\nEq. eqrefvar_sw_voltage_to - variable_bus_voltage\nEq. eqrefvar_sw_power - variable_switch_power\nEq. eqrefeq_sw_voltage - constraint_switch_on_off or constraint_switch_state\nEq. eqrefeq_sw_thermal_limit - constraint_switch_thermal_limit\nEq. eqrefeq_sw_current_limit - not yet implemented","category":"page"},{"location":"power-flow/#Power-Flow-Computations","page":"Power Flow","title":"Power Flow Computations","text":"","category":"section"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"The typical goal of PowerModels is to build a JuMP model that is used to solve power network optimization problems.  The JuMP model abstraction enables PowerModels to have state-of-the-art performance on a wide range of problem formulations including those with discrete variables and complex non-linear constraints, such as semi-definite cones.  That said, for the specific case of power flow computations, in some specific applications performance gains can be had by avoiding the JuMP model abstraction and solving the problem more directly.  To that end, PowerModels includes Julia-native solvers for AC power flow in polar voltage coordinates and the DC power flow approximation. This section provides an overview of the different power flow options that are available in PowerModels and under what circumstances they may be beneficial.","category":"page"},{"location":"power-flow/#Generic-Power-Flow","page":"Power Flow","title":"Generic Power Flow","text":"","category":"section"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"The general purpose power flow solver in PowerModels is,","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"solve_pf","category":"page"},{"location":"power-flow/#PowerModels.solve_pf","page":"Power Flow","title":"PowerModels.solve_pf","text":"solves a formulation-agnostic Power Flow using a JuMP model\n\n\n\n\n\n","category":"function"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"This function builds a JuMP model for a wide variety of the power flow formulations supported by PowerModels.  For example it supports,","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"ACPPowerModel - a non-convex nonlinear AC power flow using complex voltages in polar coordinates\nACRPowerModel - a non-convex nonlinear AC power flow using complex voltages in rectangular coordinates\nSOCWRPowerModel - a convex quadratic relaxation of the power flow problem\nDCPPowerModel - a linear DC approximation of the power flow problem","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"The typical ACPPowerModel and DCPPowerModel formulations are available via the shorthand form solve_ac_pf and solve_dc_pf respectively.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"The solve_pf solution method is both formulation and solver agnostic and can leverage the wide range of solvers that are available in the JuMP ecosystem.  Many of these solvers are commercial-grade, which in turn makes solve_pf the most reliable power flow solution method in PowerModels.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"note: Note\nUse of solve_pf is highly recommended over the other solution methods for increased robustness.  Applications that benefit from the Julia native solution methods are an exception to this general rule.","category":"page"},{"location":"power-flow/#Warm-Starting","page":"Power Flow","title":"Warm Starting","text":"","category":"section"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"In some applications an initial guess of the power flow solution may be available.  In such a case, this information may be able to decrease a solver's time to convergence, especial when solving systems of nonlinear equations. The _start postfix can be used in the network data to initialize the solver's variables and provide a suitable solution guess.  The most common values are as follows,","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"For each generator,","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"pg_start - active power injection starting point\nqg_start - reactive power injection starting point","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"For each bus,","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"vm_start - voltage magnitude starting point for the ACPPowerModel model\nva_start - voltage angle starting point for the ACPPowerModel model\nvr_start - real voltage starting point for the ACRPowerModel model\nvi_start - imaginary voltage starting point for the ACRPowerModel model","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"The following helper function can be used to use the solution point in the network data as the starting point for solve_ac_pf.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"set_ac_pf_start_values!","category":"page"},{"location":"power-flow/#PowerModels.set_ac_pf_start_values!","page":"Power Flow","title":"PowerModels.set_ac_pf_start_values!","text":"takes the current ac solution and configures it a starting value for an ac power flow solver\n\n\n\n\n\n","category":"function"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"warning: Warning\nWarm starting a solver is a very delicate task and can easily result in degraded performance.  Using PowerModels' default flat-start values is recommended before experimenting with warm starting a solver.","category":"page"},{"location":"power-flow/#Native-AC-Power-Flow","page":"Power Flow","title":"Native AC Power Flow","text":"","category":"section"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"The AC Power Flow problem is ubiquitous in power system analysis. The problem requires solving a system of nonlinear equations, usually via a Newton-Raphson type of algorithm.  In PowerModels, the package NLSolve is used for solving this system of nonlinear equations.  NLsolve provides a variety of established solution methods.  The following function is used to solve AC Power Flow problem with voltages in polar coordinates with NLsolve.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"compute_ac_pf","category":"page"},{"location":"power-flow/#PowerModels.compute_ac_pf","page":"Power Flow","title":"PowerModels.compute_ac_pf","text":"Computes a nonlinear AC power flow in polar coordinates based on the admittance matrix of the network data using the NLsolve package.  See the NLsolve documentation for solver configuration parameters.\n\nReturns a solution data structure in PowerModels Dict format\n\n\n\n\n\n","category":"function"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"compute_ac_pf will typically provide an identical result to solve_ac_pf. However, the existence of solution degeneracy around generator injection assignments and multiple power flow solutions can yield different results. The primary advantage of compute_ac_pf over solve_ac_pf is that it does not require building a JuMP model.  If the initial point for the AC Power Flow solution is near-feasible then compute_ac_pf can result in a significant runtime saving by converging quickly and reducing data-wrangling and memory allocation overheads.  This initial guess is provided using the standard _start values.  The set_ac_pf_start_values! function provides a convenient way of setting a suitable starting point.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"tip: Tip\nIf compute_ac_pf fails to converge try solve_ac_pf instead.","category":"page"},{"location":"power-flow/#Native-DC-Power-Flow","page":"Power Flow","title":"Native DC Power Flow","text":"","category":"section"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"At its core the DC Power Flow problem simply requires solving a system of  linear equations.  This can be done natively in Julia via the \\ operator. The following function can be used to solve a DC Power Flow using Julia's built-in linear systems solvers.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"compute_dc_pf","category":"page"},{"location":"power-flow/#PowerModels.compute_dc_pf","page":"Power Flow","title":"PowerModels.compute_dc_pf","text":"computes a linear DC power flow based on the susceptance matrix of the network data using Julia's native linear equation solvers.\n\nreturns a solution data structure in PowerModels Dict format\n\n\n\n\n\n","category":"function"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"The compute_dc_pf method should provide identical results to solve_dc_pf. The primary advantage of compute_dc_pf over solve_dc_pf is that it does not require building a JuMP model.  This results in significant memory saving and marginal performance saving due to reduced data-wrangling overhead.  The primary use-case of this model is to compute the voltage angle values from a collection of bus injections when working with a formulation that does not explicitly model these values, such as a PTDF or LODF formulation. The solve_opf_ptdf_branch_power_cuts utility function provides an example of how compute_dc_pf is typically used.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"This solver does not support warm starting.","category":"page"},{"location":"power-flow/#Branch-Flow-Values","page":"Power Flow","title":"Branch Flow Values","text":"","category":"section"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"By default none of the Power Flow solvers produce branch flow values. If needed, these can be computed with the network data functions,","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"calc_branch_flow_ac\ncalc_branch_flow_dc","category":"page"},{"location":"power-flow/#PowerModels.calc_branch_flow_ac","page":"Power Flow","title":"PowerModels.calc_branch_flow_ac","text":"assumes a valid ac solution is included in the data and computes the branch flow values\n\n\n\n\n\n","category":"function"},{"location":"power-flow/#PowerModels.calc_branch_flow_dc","page":"Power Flow","title":"PowerModels.calc_branch_flow_dc","text":"assumes a vaild dc solution is included in the data and computes the branch flow values\n\n\n\n\n\n","category":"function"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"Both of these methods require a complete network data with a valid voltage solution for computing the branch flows.  For example, one common work flow to recover branch flow values is,","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"result = solve_ac_pf(network, ...)\n# check that the solver converged\nupdate_data!(network, result[\"solution\"])\nflows = calc_branch_flow_ac(network)\nupdate_data!(network, flows)","category":"page"},{"location":"power-flow/#Network-Admittance-Matrix","page":"Power Flow","title":"Network Admittance Matrix","text":"","category":"section"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"Internally compute_ac_pf and compute_dc_pf utilize an admittance matrix representation of the network data, which may be useful in other contexts. The foundational type for both representations is AdmittanceMatrix{T}.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"AdmittanceMatrix","category":"page"},{"location":"power-flow/#PowerModels.AdmittanceMatrix","page":"Power Flow","title":"PowerModels.AdmittanceMatrix","text":"Stores data related to an Admittance Matrix.  Work with both complex (i.e. Y) and real-valued (e.g. B) valued admittance matrices.  Only supports sparse matrices.\n\nidx_to_bus - a mapping from 1-to-n bus idx values to data model bus ids\nbus_to_idx - a mapping from data model bus ids to 1-to-n bus idx values\nmatrix - the sparse admittance matrix values\n\n\n\n\n\n","category":"type"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"In the case of an full admittance matrix and simplified susceptance the type is  AdmittanceMatrix{Complex{Float64}} and AdmittanceMatrix{Float64}, respectively.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"The following functions can be used to compute the admittance matrix and susceptance matrix from PowerModels network data.","category":"page"},{"location":"power-flow/","page":"Power Flow","title":"Power Flow","text":"calc_admittance_matrix\ncalc_susceptance_matrix","category":"page"},{"location":"power-flow/#PowerModels.calc_admittance_matrix","page":"Power Flow","title":"PowerModels.calc_admittance_matrix","text":"data should be a PowerModels network data model; only supports networks with exactly one reference bus\n\n\n\n\n\n","category":"function"},{"location":"power-flow/#PowerModels.calc_susceptance_matrix","page":"Power Flow","title":"PowerModels.calc_susceptance_matrix","text":"data should be a PowerModels network data model; only supports networks with exactly one refrence bus\n\n\n\n\n\n","category":"function"},{"location":"objective/#Objective","page":"Objective","title":"Objective","text":"","category":"section"},{"location":"objective/","page":"Objective","title":"Objective","text":"PowerModels includes support for cost functions provided as either univariate polynomials or piecewise linear functions. These functions are encoded in the generator and dcline components following the conventions of the Matpower data format. The implementation of the piecewise linear cost functions uses an auxiliary variable implementation often referred to as the lambda formulation. Additional information about this formulation and why it is used can be found in this technical report.","category":"page"},{"location":"objective/","page":"Objective","title":"Objective","text":"The objective functions that include the term fuel_and_flow capture cost functions on both generator and dcline components, while the names only including the term fuel work exclusively on generator components and ignore any cost data relating to dcline components.","category":"page"},{"location":"objective/","page":"Objective","title":"Objective","text":"Modules = [PowerModels]\nPages   = [\"core/objective.jl\"]\nOrder   = [:function]\nPrivate  = true","category":"page"},{"location":"objective/#PowerModels.calc_pwl_points-Tuple{Int64, Vector{<:Real}, Real, Real}","page":"Objective","title":"PowerModels.calc_pwl_points","text":"cleans up raw pwl cost points in preparation for building a mathamatical model.\n\nThe key mathematical properties,\n\nthe first and last points are strictly outside of the pmin-to-pmax range\npmin and pmax occur in the first and last line segments.\n\n\n\n\n\n","category":"method"},{"location":"objective/#PowerModels.expression_p_dc_cost-Tuple{AbstractPowerModel}","page":"Objective","title":"PowerModels.expression_p_dc_cost","text":"adds pdccost variables and constraints\n\n\n\n\n\n","category":"method"},{"location":"objective/#PowerModels.expression_pg_cost-Tuple{AbstractPowerModel}","page":"Objective","title":"PowerModels.expression_pg_cost","text":"adds pg_cost variables and constraints\n\n\n\n\n\n","category":"method"},{"location":"objective/#PowerModels.objective_min_fuel_and_flow_cost-Tuple{AbstractPowerModel}","page":"Objective","title":"PowerModels.objective_min_fuel_and_flow_cost","text":"\n\n\n\n","category":"method"},{"location":"#PowerModels.jl-Documentation","page":"Home","title":"PowerModels.jl Documentation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"CurrentModule = PowerModels","category":"page"},{"location":"#Overview","page":"Home","title":"Overview","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"PowerModels.jl is a Julia/JuMP package for Steady-State Power Network Optimization. It provides utilities for parsing and modifying network data (see PowerModels Network Data Format for details), and is designed to enable computational evaluation of emerging power network formulations and algorithms in a common platform.","category":"page"},{"location":"","page":"Home","title":"Home","text":"The code is engineered to decouple Problem Specifications (e.g. Power Flow, Optimal Power Flow, ...) from the Formulation Details (e.g. AC, DC approximation, SOC relaxation, ...). This enables the definition of a wide variety of power network formulations and their comparison on common problem specifications.","category":"page"},{"location":"#Installation","page":"Home","title":"Installation","text":"","category":"section"},{"location":"","page":"Home","title":"Home","text":"The latest stable release of PowerModels can be installed using the Julia package manager with","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add PowerModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"For the current development version, \"checkout\" this package with","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add PowerModels#master","category":"page"},{"location":"","page":"Home","title":"Home","text":"At least one solver is required for running PowerModels.  The open-source solver Ipopt is recommended, as it is fast, scaleable and can be used to solve a wide variety of the problems and network formulations provided in PowerModels.  The Ipopt solver can be installed via the package manager with","category":"page"},{"location":"","page":"Home","title":"Home","text":"] add Ipopt","category":"page"},{"location":"","page":"Home","title":"Home","text":"Test that the package works by running","category":"page"},{"location":"","page":"Home","title":"Home","text":"] test PowerModels","category":"page"},{"location":"","page":"Home","title":"Home","text":"PowerModels' tests are comprehensive and can take as long as 10 minutes to complete.","category":"page"}]
}
