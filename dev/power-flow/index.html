<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power Flow · PowerModels</title><meta name="title" content="Power Flow · PowerModels"/><meta property="og:title" content="Power Flow · PowerModels"/><meta property="twitter:title" content="Power Flow · PowerModels"/><meta name="description" content="Documentation for PowerModels."/><meta property="og:description" content="Documentation for PowerModels."/><meta property="twitter:description" content="Documentation for PowerModels."/><script async src="https://www.googletagmanager.com/gtag/js?id=UA-367975-10"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-367975-10', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PowerModels logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PowerModels</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickguide/">Getting Started</a></li><li><a class="tocitem" href="../network-data/">Network Data Format</a></li><li><a class="tocitem" href="../result-data/">Result Data Format</a></li><li><a class="tocitem" href="../math-model/">Mathematical Model</a></li><li class="is-active"><a class="tocitem" href>Power Flow</a><ul class="internal"><li><a class="tocitem" href="#Generic-Power-Flow"><span>Generic Power Flow</span></a></li><li><a class="tocitem" href="#Native-AC-Power-Flow"><span>Native AC Power Flow</span></a></li><li><a class="tocitem" href="#Native-DC-Power-Flow"><span>Native DC Power Flow</span></a></li><li><a class="tocitem" href="#Branch-Flow-Values"><span>Branch Flow Values</span></a></li><li><a class="tocitem" href="#Network-Admittance-Matrix"><span>Network Admittance Matrix</span></a></li></ul></li><li><a class="tocitem" href="../storage/">Storage Model</a></li><li><a class="tocitem" href="../switch/">Switch Model</a></li><li><a class="tocitem" href="../multi-networks/">Multi Networks</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../basic-data-utilities/">Basic Data Utilities</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../formulations/">Network Formulations</a></li><li><a class="tocitem" href="../specifications/">Problem Specifications</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Modeling Components</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">PowerModel</a></li><li><a class="tocitem" href="../objective/">Objective</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li></ul></li><li><a class="tocitem" href="../relaxations/">Relaxation Schemes</a></li><li><a class="tocitem" href="../parser/">File IO</a></li></ul></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../developer/">Developer</a></li><li><a class="tocitem" href="../formulation-details/">Formulation Details</a></li></ul></li><li><a class="tocitem" href="../experiment-results/">Experiment Results</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/lanl-ansi/PowerModels.jl" title="View the repository on GitHub"><span class="docs-icon fa-brands"></span><span class="docs-label is-hidden-touch">GitHub</span></a><a class="docs-navbar-link" href="https://github.com/lanl-ansi/PowerModels.jl/blob/master/docs/src/power-flow.md" title="Edit source on GitHub"><span class="docs-icon fa-solid"></span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="Power-Flow-Computations"><a class="docs-heading-anchor" href="#Power-Flow-Computations">Power Flow Computations</a><a id="Power-Flow-Computations-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Computations" title="Permalink"></a></h1><p>The typical goal of PowerModels is to build a JuMP model that is used to solve power network optimization problems.  The JuMP model abstraction enables PowerModels to have state-of-the-art performance on a wide range of problem formulations including those with discrete variables and complex non-linear constraints, such as semi-definite cones.  That said, for the specific case of power flow computations, in some specific applications performance gains can be had by avoiding the JuMP model abstraction and solving the problem more directly.  To that end, PowerModels includes Julia-native solvers for AC power flow in polar voltage coordinates and the DC power flow approximation. This section provides an overview of the different power flow options that are available in PowerModels and under what circumstances they may be beneficial.</p><h2 id="Generic-Power-Flow"><a class="docs-heading-anchor" href="#Generic-Power-Flow">Generic Power Flow</a><a id="Generic-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Power-Flow" title="Permalink"></a></h2><p>The general purpose power flow solver in PowerModels is,</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.solve_pf" href="#PowerModels.solve_pf"><code>PowerModels.solve_pf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>solves a formulation-agnostic Power Flow using a JuMP model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/prob/pf.jl#L11">source</a></section></article><p>This function builds a JuMP model for a wide variety of the power flow formulations supported by PowerModels.  For example it supports,</p><ul><li><code>ACPPowerModel</code> - a non-convex nonlinear AC power flow using complex voltages in polar coordinates</li><li><code>ACRPowerModel</code> - a non-convex nonlinear AC power flow using complex voltages in rectangular coordinates</li><li><code>SOCWRPowerModel</code> - a convex quadratic relaxation of the power flow problem</li><li><code>DCPPowerModel</code> - a linear DC approximation of the power flow problem</li></ul><p>The typical <code>ACPPowerModel</code> and <code>DCPPowerModel</code> formulations are available via the shorthand form <code>solve_ac_pf</code> and <code>solve_dc_pf</code> respectively.</p><p>The <code>solve_pf</code> solution method is both formulation and solver agnostic and can leverage the wide range of solvers that are available in the JuMP ecosystem.  Many of these solvers are commercial-grade, which in turn makes <code>solve_pf</code> the most reliable power flow solution method in PowerModels.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Use of <code>solve_pf</code> is highly recommended over the other solution methods for increased robustness.  Applications that benefit from the Julia native solution methods are an exception to this general rule.</p></div></div><h3 id="Warm-Starting"><a class="docs-heading-anchor" href="#Warm-Starting">Warm Starting</a><a id="Warm-Starting-1"></a><a class="docs-heading-anchor-permalink" href="#Warm-Starting" title="Permalink"></a></h3><p>In some applications an initial guess of the power flow solution may be available.  In such a case, this information may be able to decrease a solver&#39;s time to convergence, especial when solving systems of nonlinear equations. The <code>_start</code> postfix can be used in the network data to initialize the solver&#39;s variables and provide a suitable solution guess.  The most common values are as follows,</p><p>For each generator,</p><ul><li><code>pg_start</code> - active power injection starting point</li><li><code>qg_start</code> - reactive power injection starting point</li></ul><p>For each bus,</p><ul><li><code>vm_start</code> - voltage magnitude starting point for the <code>ACPPowerModel</code> model</li><li><code>va_start</code> - voltage angle starting point for the <code>ACPPowerModel</code> model</li><li><code>vr_start</code> - real voltage starting point for the <code>ACRPowerModel</code> model</li><li><code>vi_start</code> - imaginary voltage starting point for the <code>ACRPowerModel</code> model</li></ul><p>The following helper function can be used to use the solution point in the network data as the starting point for <code>solve_ac_pf</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.set_ac_pf_start_values!" href="#PowerModels.set_ac_pf_start_values!"><code>PowerModels.set_ac_pf_start_values!</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>takes the current ac solution and configures it a starting value for an ac power flow solver</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/core/data.jl#L707">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Warm starting a solver is a very delicate task and can easily result in degraded performance.  Using PowerModels&#39; default flat-start values is recommended before experimenting with warm starting a solver.</p></div></div><h2 id="Native-AC-Power-Flow"><a class="docs-heading-anchor" href="#Native-AC-Power-Flow">Native AC Power Flow</a><a id="Native-AC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Native-AC-Power-Flow" title="Permalink"></a></h2><p>The AC Power Flow problem is ubiquitous in power system analysis. The problem requires solving a system of nonlinear equations, usually via a Newton-Raphson type of algorithm.  In PowerModels, the package <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLSolve</a> is used for solving this system of nonlinear equations.  NLsolve provides a variety of established solution methods.  The following function is used to solve AC Power Flow problem with voltages in polar coordinates with NLsolve.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.compute_ac_pf" href="#PowerModels.compute_ac_pf"><code>PowerModels.compute_ac_pf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Computes a nonlinear AC power flow in polar coordinates based on the admittance matrix of the network data using the NLsolve package.  See the NLsolve documentation for solver configuration parameters.</p><p>Returns a solution data structure in PowerModels Dict format</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/prob/pf.jl#L286-L292">source</a></section></article><p><code>compute_ac_pf</code> will typically provide an identical result to <code>solve_ac_pf</code>. However, the existence of solution degeneracy around generator injection assignments and multiple power flow solutions can yield different results. The primary advantage of <code>compute_ac_pf</code> over <code>solve_ac_pf</code> is that it does not require building a JuMP model.  If the initial point for the AC Power Flow solution is near-feasible then <code>compute_ac_pf</code> can result in a significant runtime saving by converging quickly and reducing data-wrangling and memory allocation overheads.  This initial guess is provided using the standard <code>_start</code> values.  The <code>set_ac_pf_start_values!</code> function provides a convenient way of setting a suitable starting point.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If <code>compute_ac_pf</code> fails to converge try <code>solve_ac_pf</code> instead.</p></div></div><h2 id="Native-DC-Power-Flow"><a class="docs-heading-anchor" href="#Native-DC-Power-Flow">Native DC Power Flow</a><a id="Native-DC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Native-DC-Power-Flow" title="Permalink"></a></h2><p>At its core the DC Power Flow problem simply requires solving a system of linear equations.  This can be done natively in Julia via the <code>\</code> operator. The following function can be used to solve a DC Power Flow using Julia&#39;s built-in linear systems solvers.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.compute_dc_pf" href="#PowerModels.compute_dc_pf"><code>PowerModels.compute_dc_pf</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>computes a linear DC power flow based on the susceptance matrix of the network data using Julia&#39;s native linear equation solvers.</p><p>returns a solution data structure in PowerModels Dict format</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/prob/pf.jl#L82-L87">source</a></section></article><p>The <code>compute_dc_pf</code> method should provide identical results to <code>solve_dc_pf</code>. The primary advantage of <code>compute_dc_pf</code> over <code>solve_dc_pf</code> is that it does not require building a JuMP model.  This results in significant memory saving and marginal performance saving due to reduced data-wrangling overhead.  The primary use-case of this model is to compute the voltage angle values from a collection of bus injections when working with a formulation that does not explicitly model these values, such as a PTDF or LODF formulation. The <a href="../utilities/#PowerModels.solve_opf_ptdf_branch_power_cuts"><code>solve_opf_ptdf_branch_power_cuts</code></a> utility function provides an example of how <code>compute_dc_pf</code> is typically used.</p><p>This solver does not support warm starting.</p><h2 id="Branch-Flow-Values"><a class="docs-heading-anchor" href="#Branch-Flow-Values">Branch Flow Values</a><a id="Branch-Flow-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-Flow-Values" title="Permalink"></a></h2><p>By default none of the Power Flow solvers produce branch flow values. If needed, these can be computed with the network data functions,</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.calc_branch_flow_ac" href="#PowerModels.calc_branch_flow_ac"><code>PowerModels.calc_branch_flow_ac</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>assumes a valid ac solution is included in the data and computes the branch flow values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/core/data.jl#L721">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.calc_branch_flow_dc" href="#PowerModels.calc_branch_flow_dc"><code>PowerModels.calc_branch_flow_dc</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>assumes a vaild dc solution is included in the data and computes the branch flow values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/core/data.jl#L799">source</a></section></article><p>Both of these methods require a complete network data with a valid voltage solution for computing the branch flows.  For example, one common work flow to recover branch flow values is,</p><pre><code class="language-julia hljs">result = solve_ac_pf(network, ...)
# check that the solver converged
update_data!(network, result[&quot;solution&quot;])
flows = calc_branch_flow_ac(network)
update_data!(network, flows)</code></pre><h2 id="Network-Admittance-Matrix"><a class="docs-heading-anchor" href="#Network-Admittance-Matrix">Network Admittance Matrix</a><a id="Network-Admittance-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Admittance-Matrix" title="Permalink"></a></h2><p>Internally <code>compute_ac_pf</code> and <code>compute_dc_pf</code> utilize an admittance matrix representation of the network data, which may be useful in other contexts. The foundational type for both representations is <code>AdmittanceMatrix{T}</code>.</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.AdmittanceMatrix" href="#PowerModels.AdmittanceMatrix"><code>PowerModels.AdmittanceMatrix</code></a> — <span class="docstring-category">Type</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>Stores data related to an Admittance Matrix.  Work with both complex (i.e. Y) and real-valued (e.g. B) valued admittance matrices.  Only supports sparse matrices.</p><ul><li><code>idx_to_bus</code> - a mapping from 1-to-n bus idx values to data model bus ids</li><li><code>bus_to_idx</code> - a mapping from data model bus ids to 1-to-n bus idx values</li><li><code>matrix</code> - the sparse admittance matrix values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/core/admittance_matrix.jl#L5-L13">source</a></section></article><p>In the case of an full admittance matrix and simplified susceptance the type is <code>AdmittanceMatrix{Complex{Float64}}</code> and <code>AdmittanceMatrix{Float64}</code>, respectively.</p><p>The following functions can be used to compute the admittance matrix and susceptance matrix from PowerModels network data:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.calc_admittance_matrix" href="#PowerModels.calc_admittance_matrix"><code>PowerModels.calc_admittance_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>data should be a PowerModels network data model; only supports networks with exactly one reference bus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/core/admittance_matrix.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.calc_susceptance_matrix" href="#PowerModels.calc_susceptance_matrix"><code>PowerModels.calc_susceptance_matrix</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>data should be a PowerModels network data model; only supports networks with exactly one refrence bus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/core/admittance_matrix.jl#L79">source</a></section></article><p>There are similar functions for their inverses:</p><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.calc_admittance_matrix_inv" href="#PowerModels.calc_admittance_matrix_inv"><code>PowerModels.calc_admittance_matrix_inv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><p>calculates the inverse of the admittance matrix</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/core/admittance_matrix.jl#L176">source</a></section></article><article class="docstring"><header><a class="docstring-article-toggle-button fa-solid fa-chevron-down" href="javascript:;" title="Collapse docstring"></a><a class="docstring-binding" id="PowerModels.calc_susceptance_matrix_inv" href="#PowerModels.calc_susceptance_matrix_inv"><code>PowerModels.calc_susceptance_matrix_inv</code></a> — <span class="docstring-category">Function</span><span class="is-flex-grow-1 docstring-article-toggle-button" title="Collapse docstring"></span></header><section><div><pre><code class="language-julia hljs">calc_susceptance_matrix_inv(data)</code></pre><p>Compute the inverse of the network&#39;s susceptance matrix.</p><p>Note: <code>data</code>` should be a PowerModels network data model; only supports networks with exactly one refrence bus.</p><p>While the susceptance matrix is sparse, its inverse it typically quite dense. This implementation first computes a sparse factorization, then recovers the (dense)     matrix inverse via backward substitution. This is more efficient     than directly computing a dense inverse with <code>LinearAlgebra.inv</code>.</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/e17f7957823fd8218c5af1b89887474894ae27ca/src/core/admittance_matrix.jl#L139-L150">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../math-model/">« Mathematical Model</a><a class="docs-footer-nextpage" href="../storage/">Storage Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.10.2 on <span class="colophon-date" title="Thursday 8 May 2025 02:33">Thursday 8 May 2025</span>. Using Julia version 1.11.5.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
