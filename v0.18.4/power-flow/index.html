<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Power Flow · PowerModels</title><script async src="https://www.googletagmanager.com/gtag/js?id=UA-367975-10"></script><script>  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'UA-367975-10', {'page_path': location.pathname + location.search + location.hash});
</script><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.039/juliamono-regular.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.15.3/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.13.11/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.svg" alt="PowerModels logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">PowerModels</a></span></div><form class="docs-search" action="../search/"><input class="docs-search-query" id="documenter-search-query" name="q" type="text" placeholder="Search docs"/></form><ul class="docs-menu"><li><a class="tocitem" href="../">Home</a></li><li><span class="tocitem">Manual</span><ul><li><a class="tocitem" href="../quickguide/">Getting Started</a></li><li><a class="tocitem" href="../network-data/">Network Data Format</a></li><li><a class="tocitem" href="../result-data/">Result Data Format</a></li><li><a class="tocitem" href="../math-model/">Mathematical Model</a></li><li class="is-active"><a class="tocitem" href>Power Flow</a><ul class="internal"><li><a class="tocitem" href="#Generic-Power-Flow"><span>Generic Power Flow</span></a></li><li><a class="tocitem" href="#Native-AC-Power-Flow"><span>Native AC Power Flow</span></a></li><li><a class="tocitem" href="#Native-DC-Power-Flow"><span>Native DC Power Flow</span></a></li><li><a class="tocitem" href="#Branch-Flow-Values"><span>Branch Flow Values</span></a></li><li><a class="tocitem" href="#Network-Admittance-Matrix"><span>Network Admittance Matrix</span></a></li></ul></li><li><a class="tocitem" href="../storage/">Storage Model</a></li><li><a class="tocitem" href="../switch/">Switch Model</a></li><li><a class="tocitem" href="../multi-networks/">Multi Networks</a></li><li><a class="tocitem" href="../utilities/">Utilities</a></li><li><a class="tocitem" href="../basic-data-utilities/">Basic Data Utilities</a></li></ul></li><li><span class="tocitem">Library</span><ul><li><a class="tocitem" href="../formulations/">Network Formulations</a></li><li><a class="tocitem" href="../specifications/">Problem Specifications</a></li><li><input class="collapse-toggle" id="menuitem-3-3" type="checkbox"/><label class="tocitem" for="menuitem-3-3"><span class="docs-label">Modeling Components</span><i class="docs-chevron"></i></label><ul class="collapsed"><li><a class="tocitem" href="../model/">PowerModel</a></li><li><a class="tocitem" href="../objective/">Objective</a></li><li><a class="tocitem" href="../variables/">Variables</a></li><li><a class="tocitem" href="../constraints/">Constraints</a></li></ul></li><li><a class="tocitem" href="../relaxations/">Relaxation Schemes</a></li><li><a class="tocitem" href="../parser/">File IO</a></li></ul></li><li><span class="tocitem">Developer</span><ul><li><a class="tocitem" href="../developer/">Developer</a></li><li><a class="tocitem" href="../formulation-details/">Formulation Details</a></li></ul></li><li><a class="tocitem" href="../experiment-results/">Experiment Results</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><nav class="breadcrumb"><ul class="is-hidden-mobile"><li><a class="is-disabled">Manual</a></li><li class="is-active"><a href>Power Flow</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Power Flow</a></li></ul></nav><div class="docs-right"><a class="docs-edit-link" href="https://github.com/lanl-ansi/PowerModels.jl/blob/master/docs/src/power-flow.md" title="Edit on GitHub"><span class="docs-icon fab"></span><span class="docs-label is-hidden-touch">Edit on GitHub</span></a><a class="docs-settings-button fas fa-cog" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-sidebar-button fa fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a></div></header><article class="content" id="documenter-page"><h1 id="Power-Flow-Computations"><a class="docs-heading-anchor" href="#Power-Flow-Computations">Power Flow Computations</a><a id="Power-Flow-Computations-1"></a><a class="docs-heading-anchor-permalink" href="#Power-Flow-Computations" title="Permalink"></a></h1><p>The typical goal of PowerModels is to build a JuMP model that is used to solve power network optimization problems.  The JuMP model abstraction enables PowerModels to have state-of-the-art performance on a wide range of problem formulations including those with discrete variables and complex non-linear constraints, such as semi-definite cones.  That said, for the specific case of power flow computations, in some specific applications performance gains can be had by avoiding the JuMP model abstraction and solving the problem more directly.  To that end, PowerModels includes Julia-native solvers for AC power flow in polar voltage coordinates and the DC power flow approximation. This section provides an overview of the different power flow options that are available in PowerModels and under what circumstances they may be beneficial.</p><h2 id="Generic-Power-Flow"><a class="docs-heading-anchor" href="#Generic-Power-Flow">Generic Power Flow</a><a id="Generic-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Generic-Power-Flow" title="Permalink"></a></h2><p>The general purpose power flow solver in PowerModels is,</p><article class="docstring"><header><a class="docstring-binding" id="PowerModels.run_pf" href="#PowerModels.run_pf"><code>PowerModels.run_pf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>solves a formulation-agnostic Power Flow using a JuMP model</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/c67fc6e5742c13c21634782319d133e6673d98ab/src/prob/pf.jl#L11">source</a></section></article><p>This function builds a JuMP model for a wide variety of the power flow formulations supported by PowerModels.  For example it supports,</p><ul><li><code>ACPPowerModel</code> - a non-convex nonlinear AC power flow using complex voltages in polar coordinates</li><li><code>ACRPowerModel</code> - a non-convex nonlinear AC power flow using complex voltages in rectangular coordinates</li><li><code>SOCWRPowerModel</code> - a convex quadratic relaxation of the power flow problem</li><li><code>DCPPowerModel</code> - a linear DC approximation of the power flow problem</li></ul><p>The typical <code>ACPPowerModel</code> and <code>DCPPowerModel</code> formulations are available via the shorthand form <code>run_ac_pf</code> and <code>run_dc_pf</code> respectively.</p><p>The <code>run_pf</code> solution method is both formulation and solver agnostic and can leverage the wide range of solvers that are available in the JuMP ecosystem.  Many of these solvers are commercial-grade, which in turn makes <code>run_pf</code> the most reliable power flow solution method in PowerModels.</p><div class="admonition is-info"><header class="admonition-header">Note</header><div class="admonition-body"><p>Use of <code>run_pf</code> is highly recommended over the other solution methods for increased robustness.  Applications that benefit from the Julia native solution methods are an exception to this general rule.</p></div></div><h3 id="Warm-Starting"><a class="docs-heading-anchor" href="#Warm-Starting">Warm Starting</a><a id="Warm-Starting-1"></a><a class="docs-heading-anchor-permalink" href="#Warm-Starting" title="Permalink"></a></h3><p>In some applications an initial guess of the power flow solution may be available.  In such a case, this information may be able to decrease a solver&#39;s time to convergence, especial when solving systems of nonlinear equations. The <code>_start</code> postfix can be used in the network data to initialize the solver&#39;s variables and provide a suitable solution guess.  The most common values are as follows,</p><p>For each generator,</p><ul><li><code>pg_start</code> - active power injection starting point</li><li><code>qg_start</code> - reactive power injection starting point</li></ul><p>For each bus,</p><ul><li><code>vm_start</code> - voltage magnitude starting point for the <code>ACPPowerModel</code> model</li><li><code>va_start</code> - voltage angle starting point for the <code>ACPPowerModel</code> model</li><li><code>vr_start</code> - real voltage starting point for the <code>ACRPowerModel</code> model</li><li><code>vi_start</code> - imaginary voltage starting point for the <code>ACRPowerModel</code> model</li></ul><p>The following helper function can be used to use the solution point in the network data as the starting point for <code>run_ac_pf</code>.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModels.set_ac_pf_start_values!" href="#PowerModels.set_ac_pf_start_values!"><code>PowerModels.set_ac_pf_start_values!</code></a> — <span class="docstring-category">Function</span></header><section><div><p>takes the current ac solution and configures it a starting value for an ac power flow solver</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/c67fc6e5742c13c21634782319d133e6673d98ab/src/core/data.jl#L740">source</a></section></article><div class="admonition is-warning"><header class="admonition-header">Warning</header><div class="admonition-body"><p>Warm starting a solver is a very delicate task and can easily result in degraded performance.  Using PowerModels&#39; default flat-start values is recommended before experimenting with warm starting a solver.</p></div></div><h2 id="Native-AC-Power-Flow"><a class="docs-heading-anchor" href="#Native-AC-Power-Flow">Native AC Power Flow</a><a id="Native-AC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Native-AC-Power-Flow" title="Permalink"></a></h2><p>The AC Power Flow problem is ubiquitous in power system analysis. The problem requires solving a system of nonlinear equations, usually via a Newton-Raphson type of algorithm.  In PowerModels, the package <a href="https://github.com/JuliaNLSolvers/NLsolve.jl">NLSolve</a> is used for solving this system of nonlinear equations.  NLsolve provides a variety of established solution methods.  The following function is used to solve AC Power Flow problem with voltages in polar coordinates with NLsolve.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModels.compute_ac_pf" href="#PowerModels.compute_ac_pf"><code>PowerModels.compute_ac_pf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>Computes a nonlinear AC power flow in polar coordinates based on the admittance matrix of the network data using the NLsolve package.  See the NLsolve documentation for solver configuration parameters.</p><p>Returns a solution data structure in PowerModels Dict format</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/c67fc6e5742c13c21634782319d133e6673d98ab/src/prob/pf.jl#L286-L292">source</a></section></article><p><code>compute_ac_pf</code> will typically provide an identical result to <code>run_ac_pf</code>. However, the existence of solution degeneracy around generator injection assignments and multiple power flow solutions can yield different results. The primary advantage of <code>compute_ac_pf</code> over <code>run_ac_pf</code> is that it does not require building a JuMP model.  If the initial point for the AC Power Flow solution is near-feasible then <code>compute_ac_pf</code> can result in a significant runtime saving by converging quickly and reducing data-wrangling and memory allocation overheads.  This initial guess is provided using the standard <code>_start</code> values.  The <code>set_ac_pf_start_values!</code> function provides a convenient way of setting a suitable starting point.</p><div class="admonition is-success"><header class="admonition-header">Tip</header><div class="admonition-body"><p>If <code>compute_ac_pf</code> fails to converge try <code>run_ac_pf</code> instead.</p></div></div><h2 id="Native-DC-Power-Flow"><a class="docs-heading-anchor" href="#Native-DC-Power-Flow">Native DC Power Flow</a><a id="Native-DC-Power-Flow-1"></a><a class="docs-heading-anchor-permalink" href="#Native-DC-Power-Flow" title="Permalink"></a></h2><p>At its core the DC Power Flow problem simply requires solving a system of  linear equations.  This can be done natively in Julia via the <code>\</code> operator. The following function can be used to solve a DC Power Flow using Julia&#39;s built-in linear systems solvers.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModels.compute_dc_pf" href="#PowerModels.compute_dc_pf"><code>PowerModels.compute_dc_pf</code></a> — <span class="docstring-category">Function</span></header><section><div><p>computes a linear DC power flow based on the susceptance matrix of the network data using Julia&#39;s native linear equation solvers.</p><p>returns a solution data structure in PowerModels Dict format</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/c67fc6e5742c13c21634782319d133e6673d98ab/src/prob/pf.jl#L82-L87">source</a></section></article><p>The <code>compute_dc_pf</code> method should provide identical results to <code>run_dc_pf</code>. The primary advantage of <code>compute_dc_pf</code> over <code>run_dc_pf</code> is that it does not require building a JuMP model.  This results in significant memory saving and marginal performance saving due to reduced data-wrangling overhead.  The primary use-case of this model is to compute the voltage angle values from a collection of bus injections when working with a formulation that does not explicitly model these values, such as a PTDF or LODF formulation. The <a href="../utilities/#PowerModels.run_opf_ptdf_branch_power_cuts"><code>run_opf_ptdf_branch_power_cuts</code></a> utility function provides an example of how <code>compute_dc_pf</code> is typically used.</p><p>This solver does not support warm starting.</p><h2 id="Branch-Flow-Values"><a class="docs-heading-anchor" href="#Branch-Flow-Values">Branch Flow Values</a><a id="Branch-Flow-Values-1"></a><a class="docs-heading-anchor-permalink" href="#Branch-Flow-Values" title="Permalink"></a></h2><p>By default none of the Power Flow solvers produce branch flow values. If needed, these can be computed with the network data functions,</p><article class="docstring"><header><a class="docstring-binding" id="PowerModels.calc_branch_flow_ac" href="#PowerModels.calc_branch_flow_ac"><code>PowerModels.calc_branch_flow_ac</code></a> — <span class="docstring-category">Function</span></header><section><div><p>assumes a valid ac solution is included in the data and computes the branch flow values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/c67fc6e5742c13c21634782319d133e6673d98ab/src/core/data.jl#L754">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModels.calc_branch_flow_dc" href="#PowerModels.calc_branch_flow_dc"><code>PowerModels.calc_branch_flow_dc</code></a> — <span class="docstring-category">Function</span></header><section><div><p>assumes a vaild dc solution is included in the data and computes the branch flow values</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/c67fc6e5742c13c21634782319d133e6673d98ab/src/core/data.jl#L833">source</a></section></article><p>Both of these methods require a complete network data with a valid voltage solution for computing the branch flows.  For example, one common work flow to recover branch flow values is,</p><pre><code class="language-julia hljs">result = run_ac_pf(network, ...)
# check that the solver converged
update_data!(network, result[&quot;solution&quot;])
flows = calc_branch_flow_ac(network)
update_data!(network, flows)</code></pre><h2 id="Network-Admittance-Matrix"><a class="docs-heading-anchor" href="#Network-Admittance-Matrix">Network Admittance Matrix</a><a id="Network-Admittance-Matrix-1"></a><a class="docs-heading-anchor-permalink" href="#Network-Admittance-Matrix" title="Permalink"></a></h2><p>Internally <code>compute_ac_pf</code> and <code>compute_dc_pf</code> utilize an admittance matrix representation of the network data, which may be useful in other contexts. The foundational type for both representations is <code>AdmittanceMatrix{T}</code>.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModels.AdmittanceMatrix" href="#PowerModels.AdmittanceMatrix"><code>PowerModels.AdmittanceMatrix</code></a> — <span class="docstring-category">Type</span></header><section><div><p>Stores data related to an Admittance Matrix.  Work with both complex (i.e. Y) and real-valued (e.g. B) valued admittance matrices.  Only supports sparse matrices.</p><ul><li><code>idx_to_bus</code> - a mapping from 1-to-n bus idx values to data model bus ids</li><li><code>bus_to_idx</code> - a mapping from data model bus ids to 1-to-n bus idx values</li><li><code>matrix</code> - the sparse admittance matrix values</li></ul></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/c67fc6e5742c13c21634782319d133e6673d98ab/src/core/admittance_matrix.jl#L5-L13">source</a></section></article><p>In the case of an full admittance matrix and simplified susceptance the type is  <code>AdmittanceMatrix{Complex{Float64}}</code> and <code>AdmittanceMatrix{Float64}</code>, respectively.</p><p>The following functions can be used to compute the admittance matrix and susceptance matrix from PowerModels network data.</p><article class="docstring"><header><a class="docstring-binding" id="PowerModels.calc_admittance_matrix" href="#PowerModels.calc_admittance_matrix"><code>PowerModels.calc_admittance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>data should be a PowerModels network data model; only supports networks with exactly one reference bus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/c67fc6e5742c13c21634782319d133e6673d98ab/src/core/admittance_matrix.jl#L23">source</a></section></article><article class="docstring"><header><a class="docstring-binding" id="PowerModels.calc_susceptance_matrix" href="#PowerModels.calc_susceptance_matrix"><code>PowerModels.calc_susceptance_matrix</code></a> — <span class="docstring-category">Function</span></header><section><div><p>data should be a PowerModels network data model; only supports networks with exactly one refrence bus</p></div><a class="docs-sourcelink" target="_blank" href="https://github.com/lanl-ansi/PowerModels.jl/blob/c67fc6e5742c13c21634782319d133e6673d98ab/src/core/admittance_matrix.jl#L79">source</a></section></article></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../math-model/">« Mathematical Model</a><a class="docs-footer-nextpage" href="../storage/">Storage Model »</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 0.27.10 on <span class="colophon-date" title="Thursday 18 November 2021 19:02">Thursday 18 November 2021</span>. Using Julia version 1.6.3.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
